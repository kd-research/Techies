[
  {
    "Name": "Side-scrolling Camera",
    "Description": "A camera that follows the player as they move through the level, typically in a horizontal side-scrolling manner. This keeps the player character on screen and centers the view around them.",
    "Implementation Details": "Use the game engine's camera follow functions to lock the camera to the player's position. In Phaser, you would enable the camera to follow the player sprite and define world bounds so the camera doesn't show beyond the level. The camera can be set to follow smoothly or instantly, and may include dead zones (areas where the player can move without the camera shifting) for better gameplay experience.",
    "Pseudocode (Phaser.js)": "// Enable camera follow on the player\nthis.cameras.main.startFollow(player);\n \n// Optional: Set world bounds so camera stops at edges of level\nthis.cameras.main.setBounds(0, 0, levelWidth, levelHeight);\n \n// Optional: Use a smooth follow (lerp) for a more gradual camera movement\nthis.cameras.main.startFollow(player, true, 0.1, 0.1);\n \n// The above lines make the camera follow the player within the game's world bounds.",
    "Related Mechanics": ["Fixed Camera", "Dynamic Camera Zoom", "Parallax Background"]
  },
  {
    "Name": "Fixed Camera",
    "Description": "A camera view that remains static or fixed in a certain area rather than following the player everywhere. Often used in single-screen levels or rooms where the entire area is shown at once.",
    "Implementation Details": "Do not enable any follow on the camera. The camera can either cover the whole level if the level is small, or be manually moved in chunks (e.g., when the player reaches the edge of a screen, the camera jumps to the next section). Implementation can involve dividing the world into sections and moving the camera to preset coordinates when needed.",
    "Pseudocode (Phaser.js)": "// No camera follow; set camera to cover a specific area\nthis.cameras.main.setBounds(roomX, roomY, roomWidth, roomHeight);\n \n// If using multiple rooms, when transitioning to a new room:\nif (player.x > roomEndX) {\n    // Move camera to next room\n    this.cameras.main.scrollX = nextRoomX;\n    this.cameras.main.scrollY = nextRoomY;\n}",
    "Related Mechanics": ["Side-scrolling Camera", "Camera Transitions", "Dynamic Camera Zoom"]
  },
  {
    "Name": "Dynamic Camera Zoom",
    "Description": "The camera dynamically adjusts its zoom level based on game conditions (such as player speed, position, or presence of multiple players or important objects). This can zoom out to show more of the level or zoom in for detail or dramatic effect.",
    "Implementation Details": "Utilize the camera's zoom functionality to change the scale of the view. In Phaser, the camera's zoom can be changed on the fly or tweened for smooth transitions. Key considerations include ensuring important objects remain visible and adjusting any physics or UI that might be affected by the zoom. Often used to give the player a better view when moving fast or to emphasize a location.",
    "Pseudocode (Phaser.js)": "// Example: Zoom out when player is moving fast\nif (Math.abs(player.body.velocity.x) > 300) {\n    // Smoothly zoom out\n    this.cameras.main.zoom = Phaser.Math.Interpolation.Linear([this.cameras.main.zoom, 0.8], 0.5);\n} else {\n    // Zoom back in\n    this.cameras.main.zoom = Phaser.Math.Interpolation.Linear([this.cameras.main.zoom, 1], 0.5);\n}\n \n// Alternatively, use a tween for smooth zoom changes:\nthis.tweens.add({\n    targets: this.cameras.main,\n    zoom: desiredZoomLevel,\n    duration: 500\n});",
    "Related Mechanics": ["Side-scrolling Camera", "Fixed Camera", "Camera Shake"]
  },
  {
    "Name": "Parallax Background",
    "Description": "A visual effect where background layers move slower than the foreground (or player) movement, creating an illusion of depth in a 2D game. This makes the environment feel more dynamic and visually rich.",
    "Implementation Details": "Implement by using multiple layers of background images or tile sprites and setting different scroll factors for each layer. In Phaser, you can set a sprite's scrollFactor (e.g., 0.5 for a layer that moves at half the rate of the camera). As the camera moves (following the player), layers with smaller scroll factors move slower, simulating distance. Ensure that the images are wide enough or wrap seamlessly so the background doesn't run out. Parallax doesn't affect gameplay mechanics directly but enhances the visual experience of movement and camera panning.",
    "Pseudocode (Phaser.js)": "// Create background layers with different scroll factors\nlet farBG = this.add.tileSprite(0, 0, gameWidth, gameHeight, 'farBackground').setScrollFactor(0.2);\nlet midBG = this.add.tileSprite(0, 0, gameWidth, gameHeight, 'midBackground').setScrollFactor(0.5);\n \n// In update, make tileSprites scroll with camera\nfarBG.tilePositionX = this.cameras.main.scrollX * 0.2;\nmidBG.tilePositionX = this.cameras.main.scrollX * 0.5;",
    "Related Mechanics": ["Side-scrolling Camera", "Dynamic Camera Zoom"]
  },
  {
    "Name": "Jumping",
    "Description": "The ability for the player character to leap off the ground. Jumping is a fundamental movement allowing the player to overcome obstacles and reach higher platforms.",
    "Implementation Details": "Implemented by applying an upward velocity or impulse to the character when the jump input is detected, typically only if the character is on the ground (to avoid infinite jumps). Key considerations include setting a proper jump velocity, applying gravity to bring the player back down, and possibly allowing for variable jump height (e.g., a longer button press yields a higher jump). It's also common to implement a short grace period for jumping after leaving a ledge (coyote time) to make the game feel more responsive.",
    "Pseudocode (Phaser.js)": "// In update loop: check for jump input and on-ground status\nif (cursors.up.isDown && player.body.onFloor()) {\n    player.setVelocityY(-300);  // give the player an upward velocity\n}\n \n// If using variable jump height (optional):\nif (!cursors.up.isDown && player.body.velocity.y < 0) {\n    // cut the jump short if jump key released early\n    player.body.velocity.y *= 0.5;\n}",
    "Related Mechanics": ["Double Jump", "Wall Jump", "Crouching"]
  },
  {
    "Name": "Double Jump",
    "Description": "Allows the player to jump a second time in mid-air before landing. This gives the player extra reach and agility for platforming.",
    "Implementation Details": "Typically implemented by tracking the number of jumps performed since the last time the player was on the ground. The player can initiate a second jump even if not on ground, resetting or incrementing a jump counter. Once the double jump is used, further jumps are disallowed until the player lands. Design considerations include whether multiple jumps are allowed (double, triple, etc.), and providing visual or audio feedback for the second jump.",
    "Pseudocode (Phaser.js)": "// In player's state, track jumps count\nif (player.body.onFloor()) {\n    player.jumps = 0;\n}\n \n// On jump key press\nif (cursors.up.justDown) {\n    if (player.body.onFloor()) {\n        // Normal jump\n        player.setVelocityY(-300);\n        player.jumps = 1;\n    } else if (player.jumps < 2) {\n        // Double jump\n        player.setVelocityY(-300);\n        player.jumps++;\n    }\n}",
    "Related Mechanics": ["Jumping", "Wall Jump", "Flying"]
  },
  {
    "Name": "Wall Jump",
    "Description": "Enables the player to jump off a wall to reach new areas or climb upwards by alternating between walls. The player typically needs to be in contact with a wall (while in the air) and then jump, which propels them away from the wall.",
    "Implementation Details": "Implement by detecting when the player is against a wall and not on the ground. This can be done by checking collisions on the player's sides. When the jump input is pressed while touching a wall, invert the player's horizontal velocity away from the wall and give an upward boost. Often combined with a wall slide mechanic to give the player time to execute the wall jump. It's important to reset any jump counters (for double jump) upon wall jump or handle it so it doesn't allow infinite climbing by abusing double jump and wall contact.",
    "Pseudocode (Phaser.js)": "// In update: detect wall contact\nlet onLeftWall = player.body.touching.left;\nlet onRightWall = player.body.touching.right;\n \nif (cursors.up.isDown && (onLeftWall || onRightWall)) {\n    // Jump off the wall\n    player.setVelocityY(-300);\n    if (onLeftWall) {\n        player.setVelocityX(200);  // jump to the right\n    } else if (onRightWall) {\n        player.setVelocityX(-200); // jump to the left\n    }\n    // Optionally, prevent immediate re-wall-jumping by a short delay or reset jump count\n}",
    "Related Mechanics": ["Wall Slide", "Jumping", "Double Jump"]
  },
  {
    "Name": "Wall Slide",
    "Description": "When the player character presses against a vertical surface (wall) in mid-air, their fall is slowed, allowing them to slide down the wall. This gives the player more control and time to plan a wall jump or descent.",
    "Implementation Details": "Check if the player is against a wall and moving downward without being on the ground. If so, reduce the downward velocity (or apply a slight upward force) to slow the fall. In Phaser, this might involve setting a smaller gravity or directly capping the velocity when against a wall. Also, typically the player's animation changes to a sliding pose. A wall slide is often a precursor state to enable a wall jump.",
    "Pseudocode (Phaser.js)": "// In update: if pressing towards wall and falling\nif ((onLeftWall && cursors.left.isDown) || (onRightWall && cursors.right.isDown)) {\n    if (player.body.velocity.y > 50) {\n        player.body.velocity.y = 50;  // cap the fall speed while sliding\n    }\n    // Optionally, set a wall slide animation here\n}",
    "Related Mechanics": ["Wall Jump", "Jumping", "Climbing"]
  },
  {
    "Name": "Dashing",
    "Description": "A quick burst of movement in a specified direction (often horizontal) that allows the player to cover ground rapidly or dodge hazards. Dashes are usually short and may include a brief period of invincibility.",
    "Implementation Details": "Implement by listening for a dash input and then temporarily increasing the player's velocity or moving their position in the desired direction. In Phaser, you might set the player's velocityX to a high value for a short duration or use a tween to move the player. It's common to disable normal movement control during the dash and possibly give the player invulnerability frames. After dashing, enforce a cooldown before the player can dash again.",
    "Pseudocode (Phaser.js)": "// On dash input (for example, pressing a dash key)\nif (Phaser.Input.Keyboard.JustDown(dashKey) && canDash) {\n    canDash = false;\n    player.setVelocityX(player.facing === 'right' ? 600 : -600);\n    // Optionally, make the player briefly invincible or unaffected by gravity\n    player.body.allowGravity = false;\n    this.time.delayedCall(200, () => {\n        // End dash after 200ms\n        player.body.allowGravity = true;\n        player.setVelocityX(0);\n        // Restore normal gravity and control\n    });\n    // Set a cooldown for the next dash\n    this.time.delayedCall(1000, () => { canDash = true; });\n}",
    "Related Mechanics": ["Sliding", "Jumping", "Dodging"]
  },
  {
    "Name": "Sliding",
    "Description": "The player can slide along the ground, often to get through low tunnels or avoid obstacles. Usually triggered by pressing down (crouch) while running, causing the character to drop and slide forward a short distance.",
    "Implementation Details": "When the input for slide is detected (typically down or crouch while moving), switch the player to a sliding state: adjust the player's hitbox to be lower, set a fixed horizontal velocity, and possibly reduce friction so the player slides. After a set duration or distance, return the player to normal. Ensure the player cannot slide again until the first slide ends (to prevent spamming). Often accompanied by a unique animation and lower collision profile.",
    "Pseudocode (Phaser.js)": "// On slide input (e.g., down arrow while running)\nif (cursors.down.isDown && player.body.onFloor() && Math.abs(player.body.velocity.x) > 0) {\n    playerSliding = true;\n    // Reduce player collider height for the slide duration\n    player.body.setSize(player.width, player.height / 2);\n    // Give a burst of speed if not already fast\n    player.setVelocityX(player.facing === 'right' ? 400 : -400);\n    // After slide duration, reset player state\n    this.time.delayedCall(500, () => {\n        playerSliding = false;\n        player.body.setSize(player.width, player.height); // reset size\n    });\n}",
    "Related Mechanics": ["Dashing", "Crouching", "Jumping"]
  },
  {
    "Name": "Flying",
    "Description": "Allows the player to move freely in the air for an extended period or indefinitely, essentially negating gravity. This could be via a jetpack, wings, or other power-ups, and is typically limited by a resource (fuel, stamina) or time.",
    "Implementation Details": "Implement by toggling or reducing gravity's effect on the player when the fly mode is activated. The player can then be given control to move up/down as well as horizontally while flying. For example, pressing the jump button could apply an upward force continuously, or simply allow free movement in all directions. Make sure to handle transitions between flying and normal state (re-enable gravity when done). Also manage any resource (like fuel) if flight is limited.",
    "Pseudocode (Phaser.js)": "// Activate flight mode (for instance, on picking up a power-up or holding a fly key)\nplayer.body.allowGravity = false;\n \n// In update loop, when flying:\nif (cursors.up.isDown) {\n    player.setVelocityY(-200);  // move up\n} else if (cursors.down.isDown) {\n    player.setVelocityY(200);   // move down\n} else {\n    player.setVelocityY(0);\n}\n \n// Horizontal movement remains similar to walking\nif (cursors.left.isDown) {\n    player.setVelocityX(-200);\n} else if (cursors.right.isDown) {\n    player.setVelocityX(200);\n}\n \n// To disable flight (out of fuel or landing):\nplayer.body.allowGravity = true;",
    "Related Mechanics": ["Jumping", "Gliding", "Double Jump"]
  },
  {
    "Name": "Climbing",
    "Description": "The ability to climb up and down ladders or other climbable surfaces. When on a ladder, the player can move vertically (and sometimes horizontally if it's a climbing wall) at a controlled speed, often while gravity is disabled.",
    "Implementation Details": "Implement by defining specific objects or areas as climbable. When the player overlaps or collides with a ladder, switch the player's mode to a climbing state: disable gravity and allow up/down movement. Typically, horizontal movement is either disabled or limited while climbing. Once the player exits the ladder (jumping off or reaching the end), re-enable gravity and return control to normal. You may also need to snap the player to the ladder's X position for a clean climbing alignment.",
    "Pseudocode (Phaser.js)": "// Check overlap with ladder\nthis.physics.add.overlap(player, ladder, () => {\n    player.onLadder = true;\n    player.body.allowGravity = false;\n    player.setVelocityX(0); // lock horizontal movement while on ladder\n});\n \n// In update: if on ladder, allow vertical movement\nif (player.onLadder) {\n    if (cursors.up.isDown) {\n        player.setVelocityY(-100);\n    } else if (cursors.down.isDown) {\n        player.setVelocityY(100);\n    } else {\n        player.setVelocityY(0);\n    }\n    // If jump is pressed or ladder ends, get off the ladder\n    if (cursors.up.isDown && Phaser.Input.Keyboard.JustDown(jumpKey)) {\n        player.onLadder = false;\n        player.body.allowGravity = true;\n        player.setVelocityY(-300); // jump off ladder\n    }\n}\n \n// If player reaches top or bottom of ladder or moves away:\nif (!player.body.touching.ladder && player.onLadder) {\n    player.onLadder = false;\n    player.body.allowGravity = true;\n}",
    "Related Mechanics": ["Jumping", "Wall Slide", "Swimming"]
  },
  {
    "Name": "Swimming",
    "Description": "A movement mode for when the player is underwater or in a liquid. The player's movement typically becomes slower and gravity is reduced or negated, allowing buoyant movement up and down through the fluid with more drag.",
    "Implementation Details": "Implement by detecting when the player enters a water area (using overlap or a tile property). Once in water, adjust physics properties: lower gravity or even invert it slightly for buoyancy, and increase drag or reduce movement speed. The jump input can be repurposed to swim upwards (apply upward velocity), while not pressing anything lets the player slowly sink. Often, an oxygen mechanic is added (a timer for how long the player can stay underwater). On exiting the water, restore normal gravity and movement settings.",
    "Pseudocode (Phaser.js)": "// When player enters water zone\nthis.physics.add.overlap(player, waterLayer, () => {\n    player.inWater = true;\n    player.body.setDrag(100);      // increase drag to simulate water resistance\n    player.body.setGravityY(100);  // reduce gravity effect\n});\n \n// When in water, adjust controls\nif (player.inWater) {\n    if (cursors.up.isDown) {\n        player.setVelocityY(-100); // swim upward\n    } else if (cursors.down.isDown) {\n        player.setVelocityY(100);  // dive downward\n    }\n    // Horizontal movement is slower in water\n    if (cursors.left.isDown) {\n        player.setVelocityX(-100);\n    } else if (cursors.right.isDown) {\n        player.setVelocityX(100);\n    }\n}\n \n// On leaving water\nthis.physics.add.overlap(player, landExit, () => {\n    player.inWater = false;\n    player.body.setDrag(0);\n    player.body.setGravityY(300); // restore normal gravity\n});",
    "Related Mechanics": ["Flying", "Climbing", "Survival Mechanics"]
  },
  {
    "Name": "Crouching",
    "Description": "Allows the player to duck or crouch, reducing their height. This is useful for avoiding low-hanging obstacles or enemy attacks, and sometimes to initiate other actions like sliding or dropping through platforms.",
    "Implementation Details": "Implement by listening for a down input when the player is on the ground. On crouch, change the player's collider height (and possibly width) to a smaller size and adjust the sprite/animation. The player's movement speed might be reduced while crouching. If the game has one-way platforms (that can be dropped through), combining down + jump could let the player drop down through the platform. Ensure to prevent the player from standing up if an obstacle is overhead (to avoid getting stuck in a wall).",
    "Pseudocode (Phaser.js)": "// On crouch key down\nif (cursors.down.isDown && player.body.onFloor()) {\n    player.isCrouching = true;\n    player.body.setSize(player.width, player.height * 0.5); // half height\n    player.setVelocityX(0); // usually stop horizontal movement when crouching\n}\n \n// On releasing crouch\nif (player.isCrouching && cursors.down.isUp) {\n    // Before standing, check if space above is clear (pseudo-code):\n    if (spaceAboveIsClear(player)) {\n        player.isCrouching = false;\n        player.body.setSize(player.width, player.height); // restore full height\n    }\n}\n \n// Drop through platform (one-way platforms) example:\nif (player.isCrouching && Phaser.Input.Keyboard.JustDown(jumpKey)) {\n    platformCollider.active = false; // temporarily disable collision\n    this.time.delayedCall(200, () => { platformCollider.active = true; });\n}",
    "Related Mechanics": ["Sliding", "Jumping", "Stealth"]
  },
  {
    "Name": "Melee Attack",
    "Description": "A close-range attack typically executed by the player using a weapon (like a sword) or their body (punch, kick). Melee attacks usually require the player to be near an enemy to deal damage.",
    "Implementation Details": "Implement by listening for an attack input, then triggering an attack animation and detecting collisions or overlaps with enemy hitboxes during that animation. In Phaser, you might create an attack hitbox (an Arcade Physics body or use the player's body extended) that is active for a few frames. When an enemy overlaps this hitbox, reduce the enemy's health. You may also briefly disable movement or allow only limited movement during the attack. Consider combos (chaining multiple attacks) and cooldowns between attacks to balance gameplay.",
    "Pseudocode (Phaser.js)": "// On attack input\nif (Phaser.Input.Keyboard.JustDown(attackKey)) {\n    player.play('attackAnimation');\n    // Create or enable attack hitbox in front of player\n    let hitbox = playerAttackHitbox;\n    hitbox.x = player.x + (player.facing === 'right' ? 20 : -20);\n    hitbox.y = player.y;\n    hitbox.active = true;\n    // Disable hitbox after a short window\n    this.time.delayedCall(200, () => { hitbox.active = false; });\n}\n \n// Collision detection (set up in create):\nthis.physics.add.overlap(playerAttackHitbox, enemies, (hitbox, enemy) => {\n    if (hitbox.active) {\n        enemy.health -= player.attackDamage;\n        enemy.play('hitReaction');\n        if (enemy.health <= 0) {\n            enemy.destroy();\n        }\n    }\n});",
    "Related Mechanics": ["Ranged Attack", "Combo System", "Counter / Parry"]
  },
  {
    "Name": "Ranged Attack",
    "Description": "An attack performed from a distance, usually by firing a projectile (like an arrow, bullet, or magic spell). Ranged attacks allow the player to hit targets far away, often with a trade-off like limited ammo or lower damage.",
    "Implementation Details": "Implement by creating a projectile object when the attack input is pressed. In Phaser, you can use a physics group for bullets or arrows. When the player uses a ranged attack, spawn a projectile sprite at the player's position (with possibly an offset from the weapon) and give it a velocity toward the target direction (e.g., left or right based on player facing). Handle collisions between the projectile and enemies: on collision, reduce enemy health and destroy the projectile. Manage resources like ammo or cooldowns if needed to prevent spamming.",
    "Pseudocode (Phaser.js)": "// On ranged attack input\nif (Phaser.Input.Keyboard.JustDown(shootKey)) {\n    // Create a projectile at player's position\n    let bullet = bulletsGroup.create(player.x, player.y, 'bulletSprite');\n    bullet.setVelocityX(player.facing === 'right' ? 600 : -600);\n}\n \n// Projectile-Enemy collision (setup once in create)\nthis.physics.add.overlap(bulletsGroup, enemies, (bullet, enemy) => {\n    enemy.health -= player.rangedDamage;\n    bullet.destroy(); // remove projectile on hit\n    if (enemy.health <= 0) {\n        enemy.destroy();\n    }\n});\n \n// If projectiles should be limited by ammo:\nif (player.ammo > 0) {\n    player.ammo--;\n    // else, prevent shooting if no ammo\n}",
    "Related Mechanics": ["Melee Attack", "Ammo & Reload", "Power-ups"]
  },
  {
    "Name": "Counter / Parry",
    "Description": "A defensive move where the player times an input (or uses a specific move) to counter an enemy's attack, often negating the damage and stunning the enemy or dealing a return blow. This usually requires precise timing.",
    "Implementation Details": "Implement by defining a short window during which a counter action is active. For instance, if the player hits a parry button, for the next few frames the player is in a counter state. If an enemy attack hits the player during this state, the attack is negated and the enemy is stunned or takes damage. In Phaser, you might set a flag `player.isParrying = true` for a brief time and check collisions differently during that period (like if player overlaps an enemy attack hitbox while parrying). You also often play a special animation for the parry. After the window, if no attack was parried, the player may be left vulnerable for a moment to balance the mechanic.",
    "Pseudocode (Phaser.js)": "// On parry input\nif (Phaser.Input.Keyboard.JustDown(parryKey) && !player.isParrying) {\n    player.isParrying = true;\n    player.play('parryStance');\n    // Set a timer for parry active window\n    this.time.delayedCall(300, () => {\n        player.isParrying = false;\n    });\n}\n \n// In enemy attack collision logic:\nthis.physics.add.overlap(player, enemyAttackHitboxes, (playerSprite, attackHitbox) => {\n    if (player.isParrying) {\n        // Successful parry\n        attackHitbox.active = false; // negate the attack\n        let enemy = attackHitbox.owner;\n        enemy.stunned = true;\n        enemy.play('stunnedAnimation');\n        // Optionally deal counter damage or knockback to enemy\n        enemy.health -= player.parryCounterDamage;\n    } else {\n        // Player gets hit normally (apply damage)\n        player.health -= attackHitbox.damage;\n    }\n});",
    "Related Mechanics": ["Dodging", "Blocking", "Melee Attack"]
  },
  {
    "Name": "Dodging",
    "Description": "An evasive maneuver that allows the player to avoid enemy attacks or hazards, usually by quickly moving out of the way or becoming temporarily invincible. This can be a roll, slide, or short teleport depending on the game.",
    "Implementation Details": "Implement by listening for a dodge input and then executing a quick movement or state change. One common approach is a dodge-roll where the player moves a short distance quickly and is invulnerable during the roll. In Phaser, you can simulate this by setting a velocity or tweening the player's position for the dodge duration and toggling an invincibility flag or property (like ignoring collisions) briefly. After the dodge, restore the normal state. Ensure there's a brief cooldown so the player cannot dodge continuously without consequence.",
    "Pseudocode (Phaser.js)": "// On dodge input (e.g., pressing a dodge key)\nif (Phaser.Input.Keyboard.JustDown(dodgeKey) && !player.isDodging) {\n    player.isDodging = true;\n    player.invulnerable = true;\n    // Perform a quick roll in facing direction\n    let dodgeDistance = player.facing === 'right' ? 50 : -50;\n    this.tweens.add({\n        targets: player,\n        x: player.x + dodgeDistance,\n        duration: 200,\n        onComplete: () => {\n            // End dodge\n            player.isDodging = false;\n            // Delay turning off invulnerability slightly to cover entire roll\n            this.time.delayedCall(100, () => { player.invulnerable = false; });\n        }\n    });\n}",
    "Related Mechanics": ["Counter / Parry", "Dashing", "Sliding"]
  },
  {
    "Name": "Blocking",
    "Description": "A defensive mechanic where the player uses a shield or simply braces to reduce or negate damage from incoming attacks, at the cost of some stamina or other resource. While blocking, the player usually cannot attack, and movement might be limited.",
    "Implementation Details": "Implement by allowing the player to hold a block button which puts them in a blocking state. In this state, adjust damage calculation for collisions: e.g., if an enemy attack hits the player while blocking, either reduce damage or nullify it and perhaps reduce a stamina meter instead. In Phaser, you might have a flag `player.isBlocking` and check it in the enemy collision logic. Also, typically the player can't block indefinitely — a stamina or guard meter can deplete with each block, or heavy attacks break the guard.",
    "Pseudocode (Phaser.js)": "// On block button down\nif (blockKey.isDown) {\n    player.isBlocking = true;\n    player.play('blockPose');\n} else {\n    player.isBlocking = false;\n}\n \n// In enemy hit detection:\nthis.physics.add.overlap(player, enemyAttackHitboxes, (playerSprite, attackHitbox) => {\n    if (player.isBlocking) {\n        // Block the attack: reduce or nullify damage\n        player.stamina -= attackHitbox.damage * 0.5; // example: reduce stamina\n        // possibly play block spark animation\n    } else {\n        // Take full damage\n        player.health -= attackHitbox.damage;\n    }\n});",
    "Related Mechanics": ["Counter / Parry", "Dodging", "Melee Attack"]
  },
  {
    "Name": "Combo System",
    "Description": "A combat mechanic allowing the player to chain multiple attacks in sequence with varying outcomes. Each successive attack in a combo might have a different animation or effect, encouraging rhythmic button presses rather than spamming a single attack.",
    "Implementation Details": "Implement by tracking the timing and sequence of attack inputs. For example, if the player presses the attack button within a short window after the first attack, trigger a second attack animation, and then a third, etc. In Phaser, you can manage this by listening for input during or right after an attack animation. Use a state or counter for the current combo step, and reset it if too much time passes or the combo completes. Also ensure that hitting an enemy possibly resets or affects the combo (some games only allow continued combo if previous hit connected). Balancing involves deciding how many hits a combo has and the total damage vs single attacks.",
    "Pseudocode (Phaser.js)": "// Simplified combo logic\nlet comboStep = 0;\nlet comboTimer;\n \nfunction attack() {\n    if (comboStep === 0) {\n        player.play('attack1');\n    } else if (comboStep === 1) {\n        player.play('attack2');\n    } else if (comboStep === 2) {\n        player.play('attack3');\n    }\n    comboStep = (comboStep + 1) % 3;\n    // reset combo if no further input\n    if (comboTimer) comboTimer.remove(false);\n    comboTimer = this.time.delayedCall(500, () => { comboStep = 0; });\n}\n \nif (Phaser.Input.Keyboard.JustDown(attackKey)) {\n    attack();\n}",
    "Related Mechanics": ["Melee Attack", "Counter / Parry", "Dodging"]
  },
  {
    "Name": "Nested Puzzle",
    "Description": "A complex puzzle composed of multiple sub-puzzles or stages. The player must solve a series of smaller puzzles or find several clues/items that interconnect to solve the overarching puzzle.",
    "Implementation Details": "Design a nested puzzle by breaking it into parts: for example, the player might need to find multiple keys or solve multiple riddles, each of which provides a piece of a larger solution (like pieces of a code or fragments of a door mechanism). Implementation involves tracking the state of each sub-puzzle and only allowing the final resolution once all parts are completed. In Phaser, you might have several triggers or interactive objects and a variable to count progress. Ensure that feedback is given as each part is solved (e.g., one light of several lights turns on) to guide the player.",
    "Pseudocode (Phaser.js)": "// Pseudocode for a puzzle requiring 3 switches to open a door\nlet switchesActivated = 0;\n \nfunction onSwitchActivated(switch) {\n    if (!switch.isActivated) {\n        switch.isActivated = true;\n        switchesActivated++;\n        // maybe change switch sprite to indicate activation\n    }\n    if (switchesActivated === 3) {\n        door.open(); // all sub-puzzles solved, open the final door\n    }\n}\n \n// Assume each switch calls onSwitchActivated when player interacts with it.",
    "Related Mechanics": ["Movement-based Puzzle", "Music Puzzle", "Color Puzzle"]
  },
  {
    "Name": "Music Puzzle",
    "Description": "A puzzle that involves sound or musical notes. The player might have to replicate a melody, hit objects in a certain rhythmic order, or interpret audio clues to solve the puzzle.",
    "Implementation Details": "Implement by defining a sequence of notes or sounds that the player needs to match. This could involve interactive objects (like musical pillars or buttons that play notes). The game must check the order and timing of the player's inputs. For example, present a pattern (visual or audio) and require the player to repeat it. In Phaser, you can use input events on certain objects and maintain an array of the player's input sequence. Compare it to the correct sequence to determine success. Consider giving feedback for correct or incorrect notes and allowing resets if the player messes up.",
    "Pseudocode (Phaser.js)": "// Example: the correct melody as a sequence of note IDs\nconst correctMelody = ['C', 'E', 'G', 'C'];\nlet playerInputMelody = [];\n \nfunction onNoteHit(noteId) {\n    playerInputMelody.push(noteId);\n    // Check progressively\n    for (let i = 0; i < playerInputMelody.length; i++) {\n        if (playerInputMelody[i] !== correctMelody[i]) {\n            // Wrong note - reset puzzle\n            playerInputMelody = [];\n            playErrorSound();\n            return;\n        }\n    }\n    // If length matches and all correct, puzzle solved\n    if (playerInputMelody.length === correctMelody.length) {\n        openSecretDoor();\n    }\n}",
    "Related Mechanics": ["Color Puzzle", "Math Puzzle", "Nested Puzzle"]
  },
  {
    "Name": "Color Puzzle",
    "Description": "A puzzle based on colors, which might involve matching colors, arranging colored items in a certain pattern, or pressing switches in a correct color sequence. Often visual pattern recognition is key.",
    "Implementation Details": "Implement by giving visual cues and requiring the player to manipulate colored objects or inputs. For example, the player might need to change all lights to the same color or activate colored buttons in a specific order. In Phaser, each interactive object (like a colored tile or switch) can have a state or value representing its color. The puzzle logic checks if the combination of states meets the win condition. Provide hints through the environment (colored symbols, paintings, etc.). Typically, if the player fails an attempt, they can retry without permanent consequences.",
    "Pseudocode (Phaser.js)": "// Example: 4 colored orbs that need to all turn blue\nfunction onOrbInteract(orb) {\n    // Cycle the orb's color\n    orb.colorIndex = (orb.colorIndex + 1) % colors.length;\n    orb.setTexture(colors[orb.colorIndex]);\n    checkColorPuzzle();\n}\n \nfunction checkColorPuzzle() {\n    if (orbs.every(orb => orb.color === 'blue')) {\n        // Puzzle solved\n        chest.unlock();\n    }\n}\n \n// Here, colors is an array like ['red','green','blue'], and each orb has a color property.",
    "Related Mechanics": ["Music Puzzle", "Math Puzzle", "Movement-based Puzzle"]
  },
  {
    "Name": "Math Puzzle",
    "Description": "A puzzle that requires solving a mathematical or logical problem. This could range from simple arithmetic to more complex logical riddles (like sliding number puzzles or equations the player needs to balance).",
    "Implementation Details": "Implement by embedding the math or logic problem into the game environment or UI. The player might find numbers scattered around, or there might be a device that requires inputting a code that is the answer to a riddle. In Phaser, you could handle this via input fields (for numbers) or by having players move objects representing numbers into correct positions. The game checks the player's solution against the correct answer. Make sure to clearly present the problem and provide a way for the player to input their solution, and feedback for correct or incorrect attempts.",
    "Pseudocode (Phaser.js)": "// Example: a simple code input puzzle where code = 423\nlet enteredCode = [];\nfunction onNumberPadPress(num) {\n    enteredCode.push(num);\n    if (enteredCode.length === 3) {\n        if (enteredCode.join('') === '423') {\n            door.open();\n        } else {\n            enteredCode = [];\n            showError(); // reset on wrong code\n        }\n    }\n}",
    "Related Mechanics": ["Music Puzzle", "Color Puzzle", "Nested Puzzle"]
  },
  {
    "Name": "Movement-based Puzzle",
    "Description": "A puzzle that is solved through the player's movement and platforming skills rather than pure logic or code-breaking. For example, stepping on pressure plates in a specific order or within a time limit, navigating an obstacle course to activate switches, or positioning the character in certain spots to trigger events.",
    "Implementation Details": "Implement by tying puzzle triggers to the player's position or movement actions. For instance, have a series of floor buttons that must all be pressed (stepped on) within a short time, or platforms that need to be touched in a certain sequence. Use Phaser's overlap or collision detection to sense when the player is at certain locations. You might include timers to reset the puzzle if the player is too slow, forcing them to try a sequence of jumps or moves quickly. Ensure to communicate the requirements (like lights or sounds indicating which plate is next).",
    "Pseudocode (Phaser.js)": "// Example: 3 pressure plates must be activated in the correct order within time\nconst correctOrder = ['plate1','plate2','plate3'];\nlet currentStep = 0;\n \nfunction onPlateStepped(plate) {\n    if (plate.name === correctOrder[currentStep]) {\n        currentStep++;\n        plate.activate(); // visually indicate\n        if (currentStep === correctOrder.length) {\n            puzzleComplete();\n        }\n    } else {\n        // wrong plate stepped, reset puzzle\n        currentStep = 0;\n        resetAllPlates();\n    }\n    // Optionally, set a timer to reset if too slow\n    if (currentStep > 0) {\n        this.time.delayedCall(5000, () => { currentStep = 0; resetAllPlates(); });\n    }\n}",
    "Related Mechanics": ["Jumping", "Dashing", "Nested Puzzle"]
  },
  {
    "Name": "Shops / Purchasing Items",
    "Description": "Locations or interfaces where the player can buy items, equipment, or upgrades using in-game currency. Shops allow players to exchange collected currency (coins, gems, etc.) for various benefits.",
    "Implementation Details": "Implement by creating a shop entity (like an NPC or a menu) that the player can interact with. When triggered (e.g., player presses an interact key near a shopkeeper), pause the game action and bring up a shop UI listing items for sale with their prices. In Phaser, this could involve displaying text and graphics for items and listening for input to select an item. Check the player's currency amount, and if they have enough, deduct the cost and grant the item (adding to inventory or applying an upgrade). Key considerations include managing the shop inventory (static list of items or dynamic), and ensuring the player can't buy if they lack funds. Provide feedback on successful purchase or insufficient funds.",
    "Pseudocode (Phaser.js)": "// Example: Player interacts with shop NPC\nif (Phaser.Input.Keyboard.JustDown(interactKey) && checkOverlap(player, shopKeeper)) {\n    showShopMenu(); // display shop UI\n    game.scene.pause(); // pause gameplay if needed\n}\n \n// In shop menu logic:\nfunction purchaseItem(item) {\n    if (player.coins >= item.price) {\n        player.coins -= item.price;\n        giveItemToPlayer(item);\n        playSound('purchase');\n    } else {\n        playSound('error'); // not enough money\n    }\n}",
    "Related Mechanics": ["Inventory System", "Stat Upgrades", "Ammo & Reload"]
  },
  {
    "Name": "Stat Upgrades",
    "Description": "Permanent improvements to the player's attributes such as health, attack power, defense, speed, etc. Stat upgrades make the character stronger or more capable and are usually earned through leveling up, finding collectibles, or purchasing in shops.",
    "Implementation Details": "Implement by maintaining variables for player stats (e.g., maxHealth, attackPower, speed). When a stat upgrade occurs, increment these values. This can happen via different methods: experience points and levels (where reaching a new level increases stats), picking up a specific upgrade item (like a heart container to increase max health), or buying an upgrade from a shop. In Phaser, applying an upgrade might simply be a matter of changing those variables and perhaps updating UI elements (like health bar length). Ensure that any stat changes are applied immediately (e.g., if max health increases, you might also heal the player or not, depending on design). It's also important to cap stats or balance upgrades so the game remains challenging.",
    "Pseudocode (Phaser.js)": "// Example: player picks up a max health increase item\nthis.physics.add.overlap(player, healthUpgradeItem, () => {\n    player.maxHealth += 20;\n    player.health = player.maxHealth; // heal to full on pickup\n    healthUpgradeItem.destroy();\n});\n \n// Example: player buys an attack upgrade from shop\nfunction buyAttackUpgrade() {\n    if (player.coins >= upgradeCost) {\n        player.coins -= upgradeCost;\n        player.attackPower += 5;\n    }\n}",
    "Related Mechanics": ["Shops / Purchasing Items", "Power-ups", "Health System"]
  },
  {
    "Name": "Inventory System",
    "Description": "A system allowing the player to carry and manage items (weapons, potions, keys, etc.). The player can pick up items into an inventory, switch between them, or use them when needed. Inventories can have limited slots or weight, or be unlimited.",
    "Implementation Details": "Implement by having a data structure (like an array or object) to store items the player has collected. Each item could be an object with properties (name, type, quantity, etc.). In Phaser, you might not see the inventory on screen unless an inventory UI is opened. You will handle item pickup events: when the player collides with an item on the ground, add it to the inventory and remove it from the world. Also handle using items: e.g., if the player selects a potion from the inventory and uses it, apply its effect (heal, etc.) and subtract one from the inventory. Key considerations include how the player navigates the inventory (keyboard, mouse, controller), and if there are limits (like max items).",
    "Pseudocode (Phaser.js)": "// Example: picking up an item\nthis.physics.add.overlap(player, itemSprite, (playerSprite, itemSprite) => {\n    addToInventory(itemSprite.itemData);\n    itemSprite.destroy();\n});\n \nfunction addToInventory(item) {\n    // item could have properties like item.name, item.quantity\n    player.inventory.push(item);\n    updateInventoryUI();\n}\n \n// Using an item (e.g., health potion)\nfunction useItem(itemName) {\n    let index = player.inventory.findIndex(it => it.name === itemName);\n    if (index !== -1) {\n        let item = player.inventory[index];\n        if (item.name === 'Health Potion') {\n            player.health = Math.min(player.maxHealth, player.health + 50);\n        }\n        item.quantity -= 1;\n        if (item.quantity <= 0) {\n            player.inventory.splice(index, 1);\n        }\n        updateInventoryUI();\n    }\n}",
    "Related Mechanics": ["Shops / Purchasing Items", "Crafting", "Equipment System"]
  },
  {
    "Name": "Power-ups",
    "Description": "Temporary or situational upgrades the player can collect that grant special abilities or enhancements. Examples include invincibility stars, damage boosts, jump height increases, or speed boosts, often lasting for a short duration or until hit.",
    "Implementation Details": "Implement by placing power-up items in the level that the player can pick up (like any collectible). When picked up, trigger an effect: modify the player's state or stats (e.g., set player.invulnerable = true, or player.speed += X) and often set a timer for when the effect wears off. In Phaser, on overlap with the power-up sprite, apply the effect and destroy the power-up object. Use a timed event for expiration: after time ends, revert the player's stats to normal. Visual or audio indicators (like a special color or sound while powered up) help communicate the effect. Consider making the power-up mutually exclusive or stackable carefully to avoid balancing issues.",
    "Pseudocode (Phaser.js)": "// Example: speed boost power-up\nthis.physics.add.overlap(player, speedBoostItem, () => {\n    speedBoostItem.destroy();\n    player.speed *= 2;  // double the player's speed\n    playSound('powerup');\n    // Set a timer to end the effect after 5 seconds\n    this.time.delayedCall(5000, () => {\n        player.speed /= 2; // revert to normal speed\n    });\n});\n \n// Example: invincibility power-up\nthis.physics.add.overlap(player, invincibilityItem, () => {\n    invincibilityItem.destroy();\n    player.invulnerable = true;\n    this.time.delayedCall(3000, () => {\n        player.invulnerable = false;\n    });\n});",
    "Related Mechanics": ["Stat Upgrades", "Health System", "Jumping"]
  },
  {
    "Name": "Ammo & Reload",
    "Description": "A mechanic that limits the use of ranged weapons by requiring ammunition and occasionally reloading. The player must manage ammo for guns or similar weapons, and if they run out, they cannot fire until they pick up more or reload if applicable.",
    "Implementation Details": "Implement by giving the player an ammo count for relevant weapons. Each time a ranged attack is fired, decrement the ammo. If ammo reaches zero, prevent firing. For weapons that reload (like a gun magazine), you can have a max ammo per clip and a reload function that takes some time to reset ammo (if the game design includes that detail). In Phaser, simply track ammo as a variable and maybe display it on the UI. On picking up ammo packs, increase the ammo count. If reloading, you might disable shooting for a short duration while playing a reload animation or sound.",
    "Pseudocode (Phaser.js)": "// Ammo usage\nif (Phaser.Input.Keyboard.JustDown(shootKey) && player.ammo > 0) {\n    player.ammo--;\n    shootProjectile();\n    if (player.ammo === 0) {\n        clickEmptyGunSound.play();\n    }\n}\n \n// Reload mechanic\nif (Phaser.Input.Keyboard.JustDown(reloadKey) && player.ammo < player.maxAmmo) {\n    player.reloading = true;\n    player.play('reloadAnimation');\n    this.time.delayedCall(1000, () => {\n        player.ammo = player.maxAmmo;\n        player.reloading = false;\n    });\n}\n \n// Ammo pickup\nthis.physics.add.overlap(player, ammoPickup, () => {\n    player.ammo = Math.min(player.maxAmmo, player.ammo + ammoPickup.amount);\n    ammoPickup.destroy();\n});",
    "Related Mechanics": ["Ranged Attack", "Inventory System", "Shops / Purchasing Items"]
  },
  {
    "Name": "Crafting",
    "Description": "Allows the player to create new items or tools from collected resources. The player can combine materials (like wood, stone, etc.) according to recipes to craft weapons, potions, or other useful items. Common in survival or sandbox-style platformers.",
    "Implementation Details": "Implement by defining recipes that map required ingredients to an output item. The player needs an interface (e.g., a crafting menu or a crafting station in-game) to select a recipe and craft if they have the necessary materials in their inventory. In Phaser, you might manage this via a UI scene or overlay listing craftable items and checking the player's inventory counts. Upon crafting, subtract the used materials and add the crafted item to the inventory. Key considerations include how the player discovers recipes (they might be known from start or learned via pickups or NPCs) and ensuring the crafting process doesn't interrupt gameplay too much (maybe restrict crafting to safe zones).",
    "Pseudocode (Phaser.js)": "// Example pseudo-recipe\nconst recipes = {\n    'health_potion': { herb: 2, water: 1 }\n};\n \nfunction craft(itemName) {\n    let recipe = recipes[itemName];\n    if (recipe && hasMaterials(recipe)) {\n        // remove materials from inventory\n        for (let material in recipe) {\n            player.inventory[material] -= recipe[material];\n        }\n        // add crafted item\n        player.inventory[itemName] = (player.inventory[itemName] || 0) + 1;\n        playSound('craftSuccess');\n    } else {\n        playSound('craftFail');\n    }\n}\n \nfunction hasMaterials(recipe) {\n    for (let material in recipe) {\n        if (!player.inventory[material] || player.inventory[material] < recipe[material]) {\n            return false;\n        }\n    }\n    return true;\n}",
    "Related Mechanics": ["Inventory System", "Survival Mechanics", "Shops / Purchasing Items"]
  },
  {
    "Name": "Equipment System",
    "Description": "A system where the player can equip items (weapons, armor, accessories) that alter their abilities or stats. Unlike a simple inventory item, an equipped item actively changes the player's attributes or available moves.",
    "Implementation Details": "Implement by allowing certain inventory items to be marked as 'equippable'. Provide a way for the player to choose which equipment to wear or use (e.g., selecting a sword or armor from the inventory). In Phaser, you might just change the player's stats or sprite when equipment is changed. For example, equipping a sword might set the player's attack damage to a certain value or enable a new attack animation; equipping an armor could increase defense or health. Ensure that only one item per slot is equipped at a time (like one weapon, one armor, etc.), and swap accordingly. It's also useful to show the equipped items on the UI and reflect changes immediately in gameplay (like new attack animations or different projectile for a new gun).",
    "Pseudocode (Phaser.js)": "// Equipping an item (e.g., a new weapon)\nfunction equipItem(item) {\n    if (item.type === 'weapon') {\n        player.equippedWeapon = item;\n        player.attackDamage = item.attackValue;\n        player.attackType = item.attackType;\n    } else if (item.type === 'armor') {\n        player.equippedArmor = item;\n        player.defense = item.defenseValue;\n    }\n    updateEquipmentUI();\n}\n \n// Example inventory selection\nif (Phaser.Input.Keyboard.JustDown(equipKey)) {\n    let selectedItem = inventoryUI.getSelectedItem();\n    equipItem(selectedItem);\n}",
    "Related Mechanics": ["Inventory System", "Stat Upgrades", "Melee Attack"]
  },
  {
    "Name": "Survival Mechanics",
    "Description": "Gameplay elements that require the player to manage resources to stay alive beyond just avoiding enemies. This often includes systems like hunger, thirst, fatigue, temperature, or other environmental conditions that the player must monitor and maintain.",
    "Implementation Details": "Implement by introducing additional player stats such as hunger or thirst meters that deplete over time. In Phaser (or any engine), you'd decrement these values on a timer or based on actions. For example, every few seconds reduce the hunger stat; if it falls to 0, the player might start losing health. Provide ways to replenish these, like consuming food or water items (which ties into an inventory system). You might also include environmental effects: e.g., if the player is in a cold area without a heat source, a 'warmth' meter could drop. Design considerations: ensure the player has fair access to resources and that the survival aspect adds challenge without becoming too tedious. Feedback (like flashing warnings or slowing the player when starving) is important.",
    "Pseudocode (Phaser.js)": "// Initialize survival stats\nplayer.hunger = 100;\nplayer.thirst = 100;\n \n// Every second, decrease hunger and thirst\nthis.time.addEvent({\n    delay: 1000,\n    loop: true,\n    callback: () => {\n        player.hunger = Math.max(0, player.hunger - 1);\n        player.thirst = Math.max(0, player.thirst - 1);\n        if (player.hunger === 0 || player.thirst === 0) {\n            player.health -= 1; // lose health if starving or dehydrated\n        }\n    }\n});\n \n// Using food item to restore hunger\nfunction eatFood(item) {\n    player.hunger = Math.min(100, player.hunger + item.foodValue);\n    removeItemFromInventory(item);\n}",
    "Related Mechanics": ["Health System", "Inventory System", "Crafting"]
  },
  {
    "Name": "Health System",
    "Description": "The mechanics governing the player's life or hit points. This includes how much damage the player can take (hit points or health), how health is displayed (hearts, bar, number), and how the player can recover health (health pickups, regeneration) or lose it through damage.",
    "Implementation Details": "Implement by assigning a health value to the player (and enemies). In Phaser, you'd have something like player.health and player.maxHealth. Whenever the player collides with harmful objects or enemies, subtract damage from health. If health reaches zero, trigger the player's death or game over routine. Health can be visualized via a UI (like a health bar or icons). Health pickups (like medkits or heart items) can restore health when collected. Also consider invincibility frames after taking damage to prevent immediate multiple hits. For different styles: some games use a few 'hits' (like 3 hearts) rather than a numeric bar, but the concept is similar. Adjust difficulty by how frequent health refills are and how much damage enemies do.",
    "Pseudocode (Phaser.js)": "// Setting initial health\nplayer.maxHealth = 100;\nplayer.health = 100;\n \n// On player hit by enemy\nfunction onPlayerHit(damage) {\n    if (!player.invulnerable) {\n        player.health -= damage;\n        player.invulnerable = true;\n        // flash or blink player sprite to indicate hit\n        this.time.delayedCall(1000, () => { player.invulnerable = false; });\n        if (player.health <= 0) {\n            playerDies();\n        }\n    }\n}\n \n// Health pickup example\nthis.physics.add.overlap(player, healthPack, () => {\n    player.health = Math.min(player.maxHealth, player.health + 20);\n    healthPack.destroy();\n});",
    "Related Mechanics": ["One-Hit Death Mode", "Survival Mechanics", "Stat Upgrades"]
  },
  {
    "Name": "One-Hit Death Mode",
    "Description": "A game mode or mechanic where the player dies from any single hit or mistake, instead of having multiple hit points. This greatly increases the difficulty, as there is no room for error. Sometimes this is the only mode (as in certain hardcore platformers), or an optional challenge mode.",
    "Implementation Details": "Implement by setting the player's effective health to one (or treat any damage as fatal). This can be as simple as a condition in your damage handling: if the player is hit, immediately trigger death regardless of current health. Alternatively, give the player 1 HP and no health pickups. Level design should accommodate this with frequent checkpoints or shorter levels to avoid frustration. Testing is important, as one-hit-death can be very punishing. Sometimes developers include slight leniency such as a shield power-up that can negate one hit, even in one-hit mode.",
    "Pseudocode (Phaser.js)": "// Example: override damage handling for one-hit mode\nfunction onPlayerHit(damage) {\n    player.health -= damage;\n    if (damage > 0) {\n        player.health = 0; // ensure health goes to zero on any hit\n    }\n    playerDies();\n}\n \n// Alternatively, simply:\nif (playerCollidesWithEnemy) {\n    playerDies();\n}",
    "Related Mechanics": ["Health System", "Permadeath", "Checkpoint System"]
  },
  {
    "Name": "Procedural Generation",
    "Description": "The creation of game content (levels, layouts, enemy placement, etc.) algorithmically rather than manually, making each playthrough or level different. In platformers, this could mean levels are randomly generated, so the platform arrangement, obstacles, and items vary each run or for each level.",
    "Implementation Details": "Implement by writing algorithms to generate level layout at runtime. For example, one approach is to use a random combination of pre-designed 'chunks' of terrain, another is to use noise functions or dungeon generation algorithms (like random walk or binary space partitioning). In Phaser, you might programmatically create platforms by placing tiles or sprites in a procedural loop instead of loading a static level design. Key considerations include ensuring the levels remain fair and playable (no impossible jumps, etc.), and possibly seeding the random generator for reproducibility. You also need to randomize enemy and item placements. Testing is crucial to tune the algorithm so that it consistently produces fun layouts. Procedural elements can extend beyond levels to things like loot drops or enemy stats as well.",
    "Pseudocode (Phaser.js)": "// Simple example: generate platforms at random heights across a level\nfor (let x = 0; x < levelWidth; x += platformSpacing) {\n    let platformHeight = Phaser.Math.Between(minHeight, maxHeight);\n    this.physics.add.sprite(x, platformHeight, 'platform');\n}\n \n// Example: random enemy placement\nfor (let i = 0; i < numEnemies; i++) {\n    let spawnX = Phaser.Math.Between(0, levelWidth);\n    let spawnY = findGroundY(spawnX);\n    this.physics.add.sprite(spawnX, spawnY - 50, 'enemy');\n}",
    "Related Mechanics": ["Permadeath", "Survival Mechanics", "One-Hit Death Mode"]
  },
  {
    "Name": "Permadeath",
    "Description": "A feature where dying has a significant consequence, typically meaning the player must start over from the beginning of the game or level, losing most or all progress. This is common in roguelike games to raise the stakes of survival.",
    "Implementation Details": "Implement by resetting game progress upon player death. This could mean restarting the level, or in a game with multiple levels (or generated content), sending the player back to the very beginning (run reset). In practice, when the player dies, you might clear their inventory, reset stats to default, and regenerate a new world if using procedural generation. Some games incorporate a form of meta-progression where certain things remain (like unlocked characters or minor stat boosts) even after permadeath. In Phaser, you'd likely trigger a scene restart or switch to a game over scene that on confirmation restarts the game scene fresh. Testing and balancing permadeath is important to ensure the game is challenging but not too discouraging; often paired with shorter game sessions or the ability to unlock shortcuts over time.",
    "Pseudocode (Phaser.js)": "// On player death (if permadeath is enabled)\nfunction playerDies() {\n    // Clear relevant progress\n    player.inventory = [];\n    player.stats = initialStats;\n    // Restart the game or go to main menu\n    this.scene.start('GameScene'); // assuming GameScene sets up a new run\n}\n \n// Optionally, track some persistent unlocks\nif (player.reachedLevel > highestLevelAchieved) {\n    saveData.highestLevelAchieved = player.reachedLevel;\n}",
    "Related Mechanics": ["One-Hit Death Mode", "Procedural Generation", "Survival Mechanics"]
  },
  {
    "Name": "Checkpoint System",
    "Description": "Positions or markers in a level that save the player's progress, so if they die, they can respawn from that point instead of starting over. Checkpoints help reduce frustration by limiting how much progress is lost on failure.",
    "Implementation Details": "Implement by placing checkpoint objects in the level. When the player reaches or activates a checkpoint (often by touching it or interacting), record that checkpoint as the current respawn location. Typically, you'd store the checkpoint's coordinates or an identifier. If the player dies, instead of a full restart, you reposition the player at the last checkpoint and reset certain conditions (like restore some health or state). In Phaser, you might keep a variable for currentCheckpoint. Visually, checkpoints could be flags, doors, or glowing markers. Also consider whether certain things reset or remain cleared when respawning (e.g., do defeated enemies stay dead or respawn?).",
    "Pseudocode (Phaser.js)": "// On touching a checkpoint object\nthis.physics.add.overlap(player, checkpoint, () => {\n    currentCheckpoint = { x: checkpoint.x, y: checkpoint.y };\n    checkpoint.activate(); // possibly play an animation or change sprite\n});\n \n// On player death\nfunction playerDies() {\n    if (currentCheckpoint) {\n        // Respawn at checkpoint\n        player.setPosition(currentCheckpoint.x, currentCheckpoint.y);\n        player.health = player.maxHealth;\n        // Reset any necessary state (e.g., temporary power-ups)\n    } else {\n        // No checkpoint reached, restart level\n        this.scene.restart();\n    }\n}",
    "Related Mechanics": ["Health System", "Permadeath", "One-Hit Death Mode"]
  },
  {
    "Name": "Wall Climbing",
    "Description": "Allows the player character to climb vertically along walls by clinging onto them. When next to a wall, the player can latch on and move up or down slowly, expanding exploration to vertical spaces without requiring ladders. Design considerations: Wall climbing should often be limited by stamina or specific wall types so it doesn't bypass level design intended for other challenges. Player feedback such as a dedicated wall-grab animation, dust particles when latching on, and slower movement while climbing communicates the mechanic clearly. Care must be taken to ensure the player can't exploit wall climbing to reach unintended areas or get stuck.",
    "Implementation Details": "In Phaser.js (using Arcade physics), you can detect when the player is touching a wall using the physics body's blocked or touching properties. For example, if `player.body.blocked.left` or `...right` is true, the player is against a wall. When the up or down input is pressed while against a wall, temporarily reduce or nullify gravity on the player and allow a controlled vertical velocity for climbing. Typically, you'll set a flag like `isClimbing` to true, set `player.setGravityY(0)` to prevent falling, and then apply `player.setVelocityY` to let the player move up/down at a set climb speed. If the player releases the wall or reaches the top, restore normal gravity. Also implement a slight downward slide when no climb input is given to simulate gravity, unless fully stopped.",
    "Pseudocode (Phaser.js)": "if (player.body.blocked.left || player.body.blocked.right) {\n    if (cursors.up.isDown) {\n        // Begin wall climb\n        player.body.allowGravity = false;\n        player.setVelocityY(-climbSpeed);\n        player.anims.play('climb', true);\n    } else if (cursors.down.isDown) {\n        player.body.allowGravity = false;\n        player.setVelocityY(climbSpeed);\n        player.anims.play('climb', true);\n    } else {\n        // Stick to wall without moving (maybe slide slowly)\n        player.setVelocityY(slideSpeed);\n    }\n} else {\n    // Not on a wall, ensure gravity is normal\n    player.body.allowGravity = true;\n}",
    "Related Mechanics": ["Wall Jumping", "Double Jump", "Ladders"]
  },
  {
    "Name": "Grappling Hook",
    "Description": "Enables the player to fire a grappling hook to latch onto surfaces and quickly pull themselves towards that point or swing from it. This mechanic extends the player's range of movement, allowing them to reach high or far platforms that normal jumps can't. Design considerations: Grappling hooks should be limited to certain grapple points or have a cooldown to maintain challenge; otherwise players might bypass obstacles too easily. Provide clear visual cues (like dedicated grapple points or a visible rope line) and feedback (sound of the hook firing and attaching) to make usage intuitive. One challenge is handling the physics of the swing or pull smoothly so the player momentum feels natural without clipping through walls.",
    "Implementation Details": "In Phaser.js, implementing a grappling hook can be done via either a simple approach or using the physics engine. One approach is raycasting or checking a line from the player to the target direction to find a collidable surface (Phaser doesn't have built-in raycast in Arcade, but you can iterate along a vector or use Matter physics raycast). Upon hitting a valid surface, you would create a visual rope (using `Phaser.GameObjects.Line` or a chain of small segments) from the player to the hook point. You can then simulate pulling the player by disabling player gravity and setting velocity towards the hook point (using `player.setVelocity()` toward the target). For a swing effect (if using Matter physics), you could use a constraint: attach the player body to the anchor point with `Matter.Constraint` to allow realistic pendulum motion. After reaching the target or when the player cancels, remove the constraint or reset gravity to regain normal control.",
    "Pseudocode (Phaser.js)": "// Assuming use of Arcade physics for simplicity\nif (grappleButton.isDown && !player.isGrappling) {\n    let hookTarget = getGrappleTarget(player.x, player.y, aimAngle);\n    if (hookTarget) {\n        player.isGrappling = true;\n        player.body.allowGravity = false;\n        // Calculate direction vector toward target\n        let dx = hookTarget.x - player.x;\n        let dy = hookTarget.y - player.y;\n        let dist = Math.sqrt(dx*dx + dy*dy);\n        player.setVelocity(dx/dist * grappleSpeed, dy/dist * grappleSpeed);\n        // Optionally create a rope line graphic\n        ropeLine = this.add.line(0, 0, player.x, player.y, hookTarget.x, hookTarget.y, 0xFFFFFF);\n    }\n}\n// Update rope line each frame if grappling\nif (player.isGrappling) {\n    ropeLine.setTo(player.x, player.y, hookTarget.x, hookTarget.y);\n    // If player reached near the hook or presses jump to cancel\n    if (Phaser.Math.Distance.Between(player.x, player.y, hookTarget.x, hookTarget.y) < 10 || cancelKey.isDown) {\n        player.isGrappling = false;\n        player.body.allowGravity = true;\n        ropeLine.destroy();\n    }\n}",
    "Related Mechanics": ["Rope Swinging", "Wall Climbing", "Double Jump"]
  },
  {
    "Name": "Stealth Mechanics",
    "Description": "Introduces gameplay where the player avoids detection by enemies through hiding, sneaking, or staying out of sight. For example, the player might crouch to hide in tall grass or stick to shadows to not be seen by guards. Design considerations: Stealth changes the pace of the game, offering a non-combat way to overcome challenges. Enemies should have clear detection indicators (like vision cones or alertness states) so the player knows when they're at risk. Balance is key: being stealthy should be rewarding (perhaps allowing the player to bypass a tough enemy or perform a silent takedown), but getting caught should trigger a reasonable consequence (like a chase or alarm). Ensure the environment supports stealth with areas to hide and a feedback mechanism (like the player sprite dimming or an icon when hidden) so the player knows they're concealed.",
    "Implementation Details": "In Phaser.js, stealth can be implemented by combining player state management and enemy AI logic. For instance, you might give enemies a 'vision range' and 'view cone' and use a line-of-sight calculation (raycasting to the player position to check if walls obstruct view). Alternatively, simpler: check distance and whether the player is in a 'visible' state. If the player is crouching or in a designated hiding spot (could be marked by a zone or a property on a tile/sprite), set a flag `player.isHidden = true`. Enemies in their update loop can skip or reduce detection if that flag is true. You might implement enemy patrols that periodically check: if player within a certain radius and `!player.isHidden`, then trigger alert. Use Arcade overlap checks for hiding spots (e.g., a transparent object that on overlap toggles player hidden state). This is largely logic rather than physics – also consider lowering player movement speed when sneaking for realism.",
    "Pseudocode (Phaser.js)": "// In enemy update\nif (!player.isHidden && Phaser.Math.Distance.Between(enemy.x, enemy.y, player.x, player.y) < enemy.visionRange) {\n    if (hasLineOfSight(enemy, player)) {\n        enemy.setAlert(true);\n    }\n}\n// Toggling player hidden state\nif (cursors.down.isDown && player.overlap(hidingSpot)) {\n    player.isHidden = true;\n    player.setTexture('player_hidden'); // change sprite to a crouching/hiding image\n} else {\n    player.isHidden = false;\n    player.setTexture('player');\n}\n// Enemy reaction if alerted\nif (enemy.alert) {\n    enemy.chase(player);\n    // maybe spawn an exclamation icon or play alert sound\n}",
    "Related Mechanics": ["Light and Shadow Puzzles", "Crouching", "Enemy AI"]
  },
  {
    "Name": "Rope Swinging",
    "Description": "Allows the player to grab onto a hanging rope or vine and swing across gaps or obstacles. The rope is typically fixed at one end (like hanging from a tree or ceiling), and the player uses momentum to swing and then jump off to reach otherwise inaccessible areas. Design considerations: Rope swinging adds a physics-driven challenge; it should feel intuitive (perhaps automatically grab the rope if the player jumps to it) and fun. Make sure ropes are placed where needed and possibly have a bit of forgiveness in grab detection (a slightly larger grab range or auto-attach) to reduce frustration. Player feedback like the rope swaying visibly and a swinging animation helps convey momentum. Also ensure the player can't swing indefinitely to break level sequence (maybe the rope exists to get from A to B primarily).",
    "Implementation Details": "In Phaser, rope swinging can be implemented using physics (especially with Matter physics for realism). For Arcade physics, a simpler approach is to treat the rope as a point that, when grabbed, puts the player into a special swing state. In this state, you can simulate pendulum motion: perhaps by rotating the player around the rope's anchor point. Without true rotational physics in Arcade, you might manually update player's velocity or position along a circular path. Alternatively, using Matter.js, you could create a chain of constraint-linked bodies for the rope and attach the player body with a constraint joint to the rope's end upon grabbing, letting physics handle the swinging. On the code side, detect overlap or collision between the player and a rope end. On grab, disable player's gravity or normal controls and then either attach a physics constraint or run a timed swinging animation (calculating x,y via sin/cos for swing). When the player jumps off, remove the constraint or exit the swing state, re-enable gravity, and impart the player's body with the rope's momentum (velocity) to propel them.",
    "Pseudocode (Phaser.js)": "// On player overlap with rope\nthis.physics.add.overlap(player, ropeEnd, () => {\n    player.onRope = true;\n    player.body.allowGravity = false;\n    player.ropeAnchor = {x: ropeAnchor.x, y: ropeAnchor.y};\n    player.swingAngle = Math.PI / 4; // starting angle\n    player.swingSpeed = 0; // no initial angular velocity\n});\n// In update, if on rope, simulate swing\nif (player.onRope) {\n    // basic pendulum physics\n    let length = Phaser.Math.Distance.Between(player.ropeAnchor.x, player.ropeAnchor.y, player.x, player.y);\n    let gravityForce = 0.98; // some gravity constant for swing\n    player.swingSpeed += (-gravityForce / length) * Math.sin(player.swingAngle);\n    player.swingAngle += player.swingSpeed;\n    // Update player position based on angle\n    player.x = player.ropeAnchor.x + length * Math.sin(player.swingAngle);\n    player.y = player.ropeAnchor.y + length * Math.cos(player.swingAngle);\n    // If jump key pressed to release\n    if (cursors.up.isDown) {\n        player.onRope = false;\n        player.body.allowGravity = true;\n        // Apply momentum from swing to player velocity\n        player.setVelocity(player.x - player.ropeAnchor.x, player.y - player.ropeAnchor.y);\n    }\n}",
    "Related Mechanics": ["Grappling Hook", "Jumping", "Ladders"]
  },
  {
    "Name": "Destructible Environments",
    "Description": "Certain parts of the game world can be destroyed or altered by the player's actions or other events. Examples include breakable crates, walls that can be blown up, or floors that collapse after a heavy impact. This mechanic adds a layer of interactivity and allows for secret areas or dynamic changes in level layout. Design considerations: Indicate destructible parts clearly (different color or cracks) so players can learn to recognize them. Ensure that destroying elements won't break the game progression or cause impossible situations (unless it's meant as a fail condition). Also consider performance if many pieces become physics objects after destruction; often debris is just cosmetic (particles or animations that fade out). Player should get satisfying feedback like screen shake or sound on destruction.",
    "Implementation Details": "In Phaser.js, destructible terrain can be handled via tilemaps or game objects. For tilemap-based levels, mark certain tiles as destructible in their properties; when an explosion or attack overlaps those tile coordinates, use `tilemap.removeTileAt(x, y)` (if using a DynamicTilemapLayer) to remove it (and perhaps replace with a 'damaged' tile or nothing). For sprite-based destructible objects (like crates or barrels), you can check collisions or overlaps: when a projectile or player attack hits the object, call `object.destroy()` to remove it from the scene, possibly after playing a break animation (`object.play('break')`). You might also spawn particle effects or smaller fragments (using `this.add.sprite` or particle emitters) to show the destruction. Be careful to only allow destruction with intended tools (e.g., a bomb explosion or a heavy attack triggers it), and disable collisions on that object after it's destroyed.",
    "Pseudocode (Phaser.js)": "// Example: bullet hitting a destructible block\nthis.physics.add.collider(bullet, destructibleBlock, () => {\n    destructibleBlock.play('break');\n    destructibleBlock.on('animationcomplete', () => {\n        destructibleBlock.destroy();\n    });\n    bullet.destroy();\n});\n// Example: bomb explosion affecting tiles\nbomb.explode = function() {\n    let explosionRadius = 2; // in tiles\n    let tileX = layer.worldToTileX(bomb.x);\n    let tileY = layer.worldToTileY(bomb.y);\n    for (let dx = -explosionRadius; dx <= explosionRadius; dx++) {\n        for (let dy = -explosionRadius; dy <= explosionRadius; dy++) {\n            let tile = layer.getTileAt(tileX+dx, tileY+dy);\n            if (tile && tile.properties.destructible) {\n                layer.removeTileAt(tileX+dx, tileY+dy);\n            }\n        }\n    }\n};",
    "Related Mechanics": ["Environmental Hazards", "Switches and Doors", "Explosives"]
  },
  {
    "Name": "Time Manipulation",
    "Description": "Gives the player control over time as a gameplay element. This can manifest as slowing down time (temporary slow-motion), freezing time completely, or even reversing time to undo actions. With time manipulation, players can navigate otherwise impossible sequences (like dodging a flurry of obstacles in slow-mo or rewinding a missed jump). Design considerations: This is a powerful ability, so it often comes with limits such as a short duration, a cooldown, or specific locations where it can be used. Visual and audio feedback is crucial – e.g., a sepia tone or motion blur during slow-mo, and distinct sound effects when time is altered – so the player clearly feels the change. Implementing reverse time is complex (you'll need to record states); if included, make sure to communicate what can and cannot be rewound (usually everything or just the player). Balance puzzles around the mechanic to avoid trivializing challenges.",
    "Implementation Details": "In Phaser.js, slowing time can be achieved by adjusting the game's time scale. Phaser 3 allows you to modify `scene.time.timeScale` or the physics world step speed (for Arcade physics `scene.physics.world.timeScale`) to globally slow down or speed up the passage of time. For freezing time, you might simply pause the physics or use `scene.pause()` for a brief period (while still allowing player input for some cool effects, depending on design). Rewinding time is more complicated: you'd have to store snapshots of game state (player position, velocities, maybe enemy states) every frame or so. To implement a rewind, on activation stop normal updates and instead step backwards through the saved states, applying them to objects. This requires a lot of memory and careful syncing of state, but can be simplified by limiting what is affected (e.g., only the player's movement rewinds or certain puzzle objects reset).",
    "Pseudocode (Phaser.js)": "// Slow motion example\nif (slowMoKey.isDown && !this.slowMoActive) {\n    this.slowMoActive = true;\n    this.physics.world.timeScale = 0.2;\n    this.time.delayedCall(1000, () => {\n        // restore normal speed after 1 second real-time (5 seconds game-time if timeScale=0.2)\n        this.physics.world.timeScale = 1;\n        this.slowMoActive = false;\n    });\n}\n// Time rewind example (player only for simplicity)\nstateBuffer.push({x: player.x, y: player.y, vx: player.body.velocity.x, vy: player.body.velocity.y});\nif (rewindKey.isDown) {\n    if (stateBuffer.length > 0) {\n        let prevState = stateBuffer.pop();\n        player.x = prevState.x;\n        player.y = prevState.y;\n        player.body.velocity.x = prevState.vx;\n        player.body.velocity.y = prevState.vy;\n    }\n}\n// (In a full implementation, you'd loop this rewind over a short duration and handle other objects similarly.)",
    "Related Mechanics": ["Teleportation", "Puzzle Elements", "Dash"]
  },
  {
    "Name": "Magnetic Surfaces",
    "Description": "Introduces magnetism as a force affecting the player or objects. Certain surfaces or objects become magnetic, attracting (or repelling) the player or metal items. For example, the player might have magnetic boots that let them walk on a metal ceiling, or a magnet gun that pulls collectible metal objects from a distance. Design considerations: Magnetic areas must be clearly distinguished (e.g., color-coded or with metal textures) so players know when magnetism will apply. If the player can toggle magnetism, there should be an indicator for when it's active. Be cautious with physics: strong magnetic pulls can make controls unpredictable, so fine-tune the force strength. Also, limit the use to intended scenarios (like specific puzzle setups) to prevent sequence breaking (e.g., don't let player stick to every wall unless the game is designed around it). This mechanic can enable unique puzzles (like moving metal blocks by attracting them or flipping gravity for the player when on a magnetic surface).",
    "Implementation Details": "Implementing magnetic effects in Phaser depends on the physics system. With Arcade physics, you can simulate a magnetic pull by applying a continuous force towards or away from the magnetic source when the player or object is in range. Arcade doesn't have real forces, but you can adjust velocity or acceleration. For instance, if the player is near a magnetic ceiling and magnetism is enabled, set `player.body.allowGravity = false` and slowly move the player upward toward the surface (simulate attraction). Alternatively, if a 'magnet power' attracts a metal object (like an item or enemy with a flag), in the update loop calculate the vector towards the player and do `metal.body.velocity.x += (dx/distance) * force` to pull it in. With Matter physics, you could use `Body.applyForce` for more realistic gradual acceleration. Also manage state: e.g., `player.hasMagnetBoots` or `player.magnetActive` to toggle magnetic behavior. Ensure to re-enable gravity or stop forces when out of range or deactivated to return to normal physics.",
    "Pseudocode (Phaser.js)": "// Magnetic boots example: stick to a ceiling\nif (player.magnetActive && player.isNearMetalCeiling) {\n    player.body.allowGravity = false;\n    // pull upward\n    player.setVelocityY(-50);\n    // if reached ceiling\n    if (player.y <= ceilingY + player.height/2) {\n        player.y = ceilingY + player.height/2;\n        player.body.velocity.y = 0;\n    }\n} else {\n    player.body.allowGravity = true;\n}\n// Magnet gun example: pulling metal objects\nmetalGroup.getChildren().forEach(metal => {\n    if (player.magnetActive) {\n        let dx = player.x - metal.x;\n        let dy = player.y - metal.y;\n        let dist = Math.sqrt(dx*dx + dy*dy);\n        if (dist < magnetRange) {\n            metal.body.velocity.x += (dx/dist) * magnetForce;\n            metal.body.velocity.y += (dy/dist) * magnetForce;\n        }\n    }\n});",
    "Related Mechanics": ["Wall Climbing", "Gravity Flip", "Puzzle Mechanics"]
  },
  {
    "Name": "Wind and Environmental Effects",
    "Description": "Adds forces and conditions in the environment that affect player movement, such as wind pushing the player, water currents, or slippery ice surfaces. Wind might blow the player in a certain direction, altering jump trajectories; ice reduces friction so the player slides; water can slow movement or push the player along a stream. Design considerations: These effects create variety and challenge by changing movement physics. They should be telegraphed (e.g., visibly blowing trees or snow for wind, shiny surface for ice) to not surprise the player unfairly. Adjust strength so they feel significant but not overly frustrating; for instance, wind that requires the player to time their movements during lulls, or ice sections that are short to avoid prolonged slippery frustration. Test thoroughly to ensure the effects integrate well with player controls and that the player can still reasonably maneuver (e.g., can they counteract wind with running, or how to build momentum on ice).",
    "Implementation Details": "In Phaser, you can achieve wind by constantly applying a velocity or acceleration to the player (and possibly other entities) in a direction while in a wind zone. For example, if a wind gust blows to the right, in the update loop do `player.setAccelerationX(windForce)` or simply add a small velocity to mimic push. You can toggle this on/off based on an area trigger or timer (for gusts). Slippery surfaces can be done by reducing friction: in Arcade, you might set `player.body.drag.x` to a low value when on ice so that they don't stop moving immediately after releasing input. Or override controls so that deceleration is slower. Water areas might be handled by changing gravity and speed: e.g., `player.setGravityY(lowerGravity)` for buoyancy and cap max velocity for a more floaty feel, and maybe prevent jumping or have a swim mechanic (multiple small jumps to simulate swimming strokes). Each environmental effect likely requires collision detection with a region (tile property or zone sprite) to toggle the effect in code.",
    "Pseudocode (Phaser.js)": "// Wind zone area effect\nif (windZone.getBounds().contains(player.x, player.y)) {\n    // Apply wind push to the right\n    player.setAccelerationX(200);\n} else {\n    player.setAccelerationX(0);\n}\n// Ice surface effect\nif (player.onIce) {\n    player.body.drag.x = 10; // very low drag, so player slides\n    // maybe limit max velocity on ice if needed\n} else {\n    player.body.drag.x = defaultDrag;\n}\n// Water region effect\nif (player.inWater) {\n    player.setGravityY(300); // less than normal gravity\n    if (cursors.up.isDown) {\n        // simple swimming upward force\n        player.setVelocityY(-100);\n    }\n    // water resistance\n    player.body.drag.x = 100;\n} else {\n    player.setGravityY(normalGravity);\n    player.body.drag.x = defaultDrag;\n}",
    "Related Mechanics": ["Environmental Hazards", "Moving Platforms", "Jumping"]
  },
  {
    "Name": "Teleportation",
    "Description": "Allows the player or objects to instantaneously move from one location to another. This often appears as teleportation portals in the level (step into one portal and emerge from another) or as a player ability to 'blink' a short distance. Teleportation enables creative level designs where direct movement is blocked but teleporters provide alternate routes; it can also serve as a quick travel mechanism in puzzles or combat escapes. Design considerations: Teleportation can easily bypass content, so restrict it appropriately (for example, fixed portal locations rather than free teleport, or line-of-sight blink). Ensure the player doesn't get disoriented: use visual cues like distinct portal colors and a brief pause or effect during teleport so the change in position is noticeable but not confusing. If it's a player-triggered ability, include a cooldown or resource cost. Also consider interaction with other mechanics, e.g., what happens if an enemy follows through a portal, or carrying objects through teleporters.",
    "Implementation Details": "In Phaser, implementing portals is straightforward with overlap events and position setting. You can create portal objects (e.g., sprites with a 'portal' tag or a specific group). Each portal might have a linked identifier to pair it with its destination. On overlap (`this.physics.add.overlap(player, portal, ...)`), you handle the teleport by setting `player.x` and `player.y` to the destination portal's coordinates. It helps to add a slight delay or toggle a flag to avoid instant re-teleporting if the destination overlaps the player with the portal immediately. For player-initiated teleport (blink), check input and determine target: for example, cast a ray or simply take the player's facing direction and desired distance, then `player.setPosition(newX, newY)`. Make sure to validate the target (not inside walls; you might do a `physics.world.overlap` check or tile collision check at the target point). You might temporarily disable collisions or input right after teleport to prevent issues. Add particle effects at the departure and arrival locations (Phaser has ParticleEmitter that you can trigger) and maybe a sound.",
    "Pseudocode (Phaser.js)": "// Portal teleportation\nthis.physics.add.overlap(player, portals, (player, portal) => {\n    if (!player.justTeleported) {\n        let destination = portals.find(p => p.id === portal.targetId);\n        if (destination) {\n            player.setPosition(destination.x, destination.y);\n            player.justTeleported = true;\n            // Prevent immediate re-trigger\n            this.time.delayedCall(500, () => { player.justTeleported = false; });\n        }\n    }\n});\n// Blink ability\nif (blinkKey.isDown && player.canBlink) {\n    let targetX = player.x + blinkDistance * (player.facingRight ? 1 : -1);\n    // Check if target is free (no wall)\n    if (!tileLayer.hasTileAtWorldXY(targetX, player.y)) {\n        // Teleport player\n        let oldX = player.x, oldY = player.y;\n        player.setPosition(targetX, player.y);\n        // Play teleport effects\n        playTeleportEffect(oldX, oldY);\n        playTeleportEffect(player.x, player.y);\n        player.canBlink = false;\n        this.time.delayedCall(1000, () => { player.canBlink = true; });\n    }\n}",
    "Related Mechanics": ["Time Manipulation", "Dash", "Puzzle Mechanics"]
  },
  {
    "Name": "Light and Shadow Puzzles",
    "Description": "Involves using light and darkness as core puzzle elements. The player might need to manipulate light sources (like pushing a mirror or turning on lamps) to illuminate certain areas or cast shadows in specific ways. For example, shining a light on a sensor might open a door, or casting a shadow on a magical floor reveals a hidden platform. These puzzles require observation and interaction with the environment rather than reflexes. Design considerations: Make sure there's a clear visual distinction for areas affected by light or darkness (using lighting effects or different colors). If dynamic lighting is too complex, scripted appearance/disappearance of objects works too. The logic should be consistent (light reveals things or triggers events, shadow conceals or deactivates them) so players learn the rules. Provide feedback when the puzzle state changes, e.g., a sound or a visual cue when a hidden object appears. Be mindful of performance if using real-time lighting; alternatively, pre-bake shadow mechanics as simpler triggers.",
    "Implementation Details": "Implementing light and shadow puzzles can range from simple triggers to complex lighting systems. Phaser 3 includes a Lights2D system that can cast lights on sprites and tilemaps. You could use this for atmosphere, but the puzzle logic still needs to be manually coded. A straightforward method: designate certain puzzle elements like 'light receptors' and 'light sources'. You might simulate a light beam by checking if an unobstructed line exists between a source and receptor (similar to a raycast, ignoring if an object is supposed to block light). When the receptor is lit (condition met), trigger whatever effect (open door, etc.). Another approach: toggling light vs dark state of the whole room - e.g., a switch turns lights on, and then previously invisible platforms (marked to only exist in darkness) now become non-collidable, while others appear. Use sprite visibility or alpha to hide/show elements as needed, and perhaps tile properties to enable/disable collisions. For example, if a 'shadow door' only opens when dark, you'd check the state and accordingly set that door sprite's active state.",
    "Pseudocode (Phaser.js)": "// Light receptor puzzle\nif (lightSource.on && hasLineOfSight(lightSource, lightReceptor)) {\n    lightReceptor.activated = true;\n    door.open();\n} else {\n    lightReceptor.activated = false;\n    door.close();\n}\n// Toggling hidden platforms with global light switch\nif (lightSwitch.isOn) {\n    hiddenPlatforms.forEach(platform => {\n        platform.disableBody(true, true); // hide and disable collision\n    });\n    visibleInLightPlatforms.forEach(platform => {\n        platform.enableBody(false, 0, 0, true, true);\n    });\n} else {\n    hiddenPlatforms.forEach(platform => {\n        platform.enableBody(false, 0, 0, true, true);\n    });\n    visibleInLightPlatforms.forEach(platform => {\n        platform.disableBody(true, true);\n    });\n}\n// Stealth integration: if implementing shadows for hiding\nif (playerInShadowArea) {\n    player.isHidden = true;\n}\nif (playerExposedToLight) {\n    player.isHidden = false;\n}",
    "Related Mechanics": ["Stealth Mechanics", "Switches and Doors", "Puzzle Mechanics"]
  }
]

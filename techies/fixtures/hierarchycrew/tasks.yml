_task_common: &task_common
  human_input: false
  async_execution: false

game_hierarchy_representation_v2:
  <<: *task_common
  agent: hierarchy_architect_v2
  description: |
      You are tasked with creating a structured XML file titled game_hierarchy.xml based on the provided game specifications. This file will serve as a detailed guide that bridges the gap between the client's game specifications and the final product of the game development pipeline. It must encapsulate all the high-level components required for the game's implementation, ensuring a clear, modular, and scalable structure.

      Follow these guidelines to produce your output as a single structured markup file called game_hierarchy.xml:

      **Setup:**
      - **Conceptual Understanding:**
        - Begin by reading and thoroughly understanding the provided game specifications.
        - Ensure you grasp all aspects of the game, including mechanics, logic, user interface (UI), audio, and any special features or edge cases.
        - Consider how each element of the game hierarchy will interact with others to ensure a cohesive and logical structure within the final XML file.

      - **File Initialization:**
        - Create an XML file titled game_hierarchy.xml. This file will serve as a comprehensive guide that outlines everything necessary for the final implementation of the game.
        - Begin with a `<Metadata>` section at the top of the XML file. This section should provide a high-level overview of the game.
        - Include a `<name>` tag within `<Metadata>` to specify the game's name.
        - Include a `<content>` tag within `<Metadata>` that contains a condensed yet comprehensive summary of the game's mechanics, logic, UI, and features. This section should encapsulate the essential elements of the game.

      **Outer Hierarchy Initialization:**
      - **Root Element Creation:**
        - As a sibling to the `<Metadata>` element, create a root `<Game>` element in the XML file. This element will contain the primary structure of the game.
        - Add a `<description>` tag within the `<Game>` element to explain its purpose and what it will encompass.

      - **Component Identification:**
        - Break down the game into its fundamental outer components. Consider elements such as:
          - **Board:** The game board or screen for games which utilize one.
          - **Logic:** Core game logic, including turn management, scoring system, and progression mechanics.
          - **Rules:** How the game is played, objective of the game, controls of the game, actions with corresponding controls.
          - **Assets:** Includes audio for sound effects and background music, and images for visual assets.
          - **Input:** Represents the player control schemas for the game (e.g., keyboard controls, mouse controls, on-screen interactables).

      **Outer Hierarchy Population:**
      - **Modularization:**
        - Ensure each identified component is modular and reusable, where possible, to allow for flexibility and scalability in the game's implementation.
      - **Element Creation:**
        - Within the `<Game>` element, create sub-elements for each major component. Each sub-element must include a `<description>` tag that:
          - Explains what the component is.
          - Details how it should be implemented.
          - Specifies the logic or interactions it involves.

        - **Example Outer Components:**
          - **Board:** `<Board>` element covering the game's board or playing window.
          - **Screens:** `<Screens>` element with sub-elements for each screen type.
          - **Logic:** `<Logic>` element covering game mechanics, including player control and scoring.
          - **Rules:** `<Rules>` element covering rules of the game, including objectives, controls and actions.
          - **Assets:** `<Assets>` element for audio and visual assets.
          - **Input:** `<Input>` element detailing the control mechanisms.

      - **Example Structure:** 
        - Here is an example of how the `<Game>` element might be populated:
          ```
          <Game>
            <Screens>
                <Description>Represents different screens in the game, such as the main menu, game screen containing the board, and endgame screen. Each screen is responsible for displaying specific information and handling user interactions related to its context.</Description>
            </Screens>
            <Logic>
                <Description>Handles the core game logic, including player control and turn management. This involves processing player inputs, updating the game state, and managing the game's progression through different levels or states.</Description>
            </Logic>
            <Rules>
              <Description>Details the guidelines for gameplay, including how objectives are achieved, how controls translate into actions, how points are scored, and how penalties are applied. It outlines win/loss conditions, scoring system, control mappings to actions, penalties for rule violations, and any unique game events or special rules.</Description>
            </Rules>
            <Assets>
                <Description>Includes all audio and visual assets necessary for the game. These assets are used to create the game's aesthetic and auditory experience, providing feedback to the player and enhancing the overall gameplay.</Description>
            </Assets>
            <Input>
                <Description>Represents the player control mechanisms for the game, including keyboard and mouse interactions. This element defines how player inputs are captured and translated into game actions.</Description>
            </Input>
          </Game>
          ```

      **Final Guidelines:**
      - Ensure all elements are detailed, focusing on the outer layers of the game hierarchy.
      - Perform no coding or sourcing in this task; your goal is to structure the XML file based on the provided specifications.
      - Your output should include the `<Metadata>`, `<Game>`, and the immediate children of the `<Game>` element, ensuring a clear and logical structure for the game's outer components.


  expected_output: >
    A .xml file, game_hierarchy.xml, that outlines the outer layer of the game's hierarchy.

game_hierarchy_inner_layers_task:
  <<: *task_common
  agent: hierarchy_entity_engineer_v2
  description: |
    You are tasked with expanding the game_hierarchy.xml file by detailing the inner layers of the game's structure. Your job is to break down each of the outer components defined in the `<Game>` element into their more detailed sub-components. This process should specify the logic, UI elements, game mechanics, player inputs, and any other necessary components. Ensure that all game mechanics, including progression, player feedback, and transitions, are logically integrated into the overall game structure.

    Follow these guidelines to produce your output as a single structured markup file called game_hierarchy.xml:

    **Setup:**
    - **Understanding the Specifications:**
      - Begin by thoroughly reviewing and fully understanding the game specifications.
      - Review the existing game_hierarchy.xml file carefully, paying attention to the structure and content of the outer components.
      - With every iteration of changes, ensure that your modifications align with the overall structure and requirements laid out in the game specifications.

    **Inner Hierarchy Population:**
    - **Expanding Each Outer Component:**
      - For every existing outer component within the `<Game>` element, identify and list all necessary sub-components.
      - These sub-components should include specific UI elements, detailed game logic segments, player interactions, assets (like images or sounds), and any additional mechanics needed for the game.
      - For each sub-component, you must:
        - Create a corresponding XML element within its respective outer component.
        - Provide a `<description>` tag for each sub-component that thoroughly explains:
          - **What the sub-component is:** Define its purpose and role within the game.
          - **How it functions:** Clearly describe the logic, behaviors, interactions, and rules associated with this sub-component. Define the component's initial state, if applicable, and what will happen to it as the game progresses.
          - **Implementation details:** Provide a step-by-step breakdown of how this component should be implemented. Include edge cases, dependencies, and how it integrates with other components.
          - **Interactions:** Specify how this sub-component interacts with other components, including any dependencies or hierarchies it is a part of.
          - Ensure that no critical elements related to gameplay, player progression, or game state transitions are omitted.

    - **Avoiding Ambiguity:**
      - When referencing specific rules, concepts, or ideas (e.g., "special pieces like bomb tiles"), ensure you do not merely mention them. Instead:
        - Fully describe these elements, including their purpose, logic, and any special handling they require.
        - Ensure that every rule or concept referenced is defined and elaborated upon within the document, with clear instructions on how it should be implemented.

    - **Examples of Detailed Inner Layers:**
      - Below are examples of how inner layers should be detailed. These examples demonstrate how to structure your XML elements and provide clear, actionable descriptions.

      **Example for Board Component:**
      ```
      <Board>
        <Description>Represents the game board where the gameplay occurs. The board is a grid that serves as the primary area for player interactions and game mechanics.</Description>
        <Grid>
          <Description>The 7x5 grid where the game tiles are placed and moved. This grid is responsible for managing the positions of all tiles during gameplay.</Description>
          <Dimensions>
            <Rows>7</Rows>
            <Columns>5</Columns>
          </Dimensions>
          <Tile>
            <Description>Individual tile component that appears on the grid. Handles merging logic, tile display, and position tracking.</Description>
            <Value>Represents the number displayed on the tile.</Value>
            <MergingLogic>
              <Description>Describes how tiles merge when they come into contact with identical tiles. Tiles merge to form a single tile with a value equal to the sum of the original tiles.</Description>
              <EdgeCases>Handles scenarios such as when multiple tiles are eligible for merging, determining the order and rules for merging.</EdgeCases>
            </MergingLogic>
          </Tile>
        </Grid>
      </Board>
      ```

      **Example for Logic Component:**
      ```
      <Logic>
        <Description>Handles core game logic, including player control, turn management, scoring system, and progression logic. This component ensures that all game rules are followed and manages the game's state transitions.</Description>
        <PieceGeneration>
          <Description>Controls the generation of pieces that fall from the top of the screen. Each piece is a cluster of tiles with random numbers.</Description>
          <RandomNumberAssignment>
            <Description>Assigns random numbers (0 to 9) to each block in the piece. Ensures randomness while avoiding patterns that could make the game too easy or too difficult.</Description>
            <FairnessAlgorithm>Implements a fairness algorithm to prevent long streaks of high or low numbers, maintaining game balance.</FairnessAlgorithm>
          </RandomNumberAssignment>
          <StandardShapes>
            <Description>Uses standard Tetris shapes (I, O, T, S, Z, L, J) for piece generation. Each shape follows specific rules for placement and rotation.</Description>
          </StandardShapes>
        </PieceGeneration>
      </Logic>
      ```

    - **Ensuring Completeness:**
      - Double-check that all elements mentioned in the outer layers are fully expanded and detailed in the inner layers.
      - Make sure that there are no references to rules, concepts, or ideas that are not explicitly defined and elaborated upon in the document.

    **Final Guidelines:**
    - Perform no coding or sourcing in this task; your goal is to detail the inner layers of the game hierarchy.
    - Focus on providing comprehensive descriptions and ensuring that all necessary information for implementing each component is included.
    - Your output should include an updated game_hierarchy.xml file with the inner layer elements filled out in their appropriate positions.
    - Think critically about the complete experience a player will have. Ensure that all core game mechanics, player interactions, and game states (from start to game over) are fully accounted for and elaborated upon in the document.
  expected_output: >
    An updated game_hierarchy.xml file with the inner layer elements filled out for the corresponding outer layer component in its appropirate position, as well as saved it in a separate XML file.

game_hierarchy_review_v2:
  <<: *task_common
  agent: hierarchy_reviewer_v2
  description: >
    You are tasked with thoroughly reviewing the game_hierarchy.xml file to ensure it aligns perfectly with the game specifications. This review process involves verifying that all components, both outer and inner layers, are correctly implemented and correspond accurately to the game specifications. If any discrepancies or areas for improvement are identified, you will propose changes and delegate the necessary adjustments to the appropriate agents.
    Review Process:
      Setup and Initial Review:
        - Understand the Game Specifications: Start by reviewing the game specifications document {game_specifications} to ensure you have a complete understanding of the game's intended design, logic, UI, and other key elements.
        - Read the XML File: Read the entire game_hierarchy.xml file from start to finish. Pay close attention to both the outer and inner layers of the hierarchy.
      
      Verification of Hierarchy Contents:
        - Cross-Check Against Specifications: For each element in the XML file, cross-reference it with the game specifications to ensure that it is correctly defined and implemented. Ensure that all described components are present and accurate, including their descriptions, logic, UI behaviors, and interactions.
        - Inner Layer Consistency: Verify that the inner layers of the hierarchy are detailed, logically structured, and consistent with the outer components they belong to. Ensure all relationships, dependencies, and interactions between components are clearly defined and appropriate.
      
      Identify Discrepancies:
        - Missing Elements: Identify any missing components or sub-components that should have been included based on the game specifications.
        - Inconsistencies: Look for inconsistencies in the descriptions, logic, or structure of the XML elements compared to the game specifications.
        - Ambiguities: Note any ambiguous or unclear descriptions that could lead to misinterpretation during implementation.
        - Localisation of logic: Check to see if the hierarchy handles all logic, anything and everything a player may encounter within the game; the logic must cover concepts such as randomness/fairness/drawing from a limited number of pieces, player input handling, and edge cases.

      Propose and Delegate Changes:
        - Propose Changes: For any discrepancies, missing elements, or areas needing improvement, propose specific changes to the XML structure or content. Document these proposed changes clearly.
        - Delegate Adjustments: Assign the task of making these adjustments to the appropriate agents:
        - Outer Layer Adjustments: Delegate to the hierarchy_architect_v2 if changes to the outer layers of the hierarchy are needed. If you instruct the addition of a new layer, follow up with the inner layers agent in order to populate the given layer.
        - Inner Layer Adjustments: Delegate to the hierarchy_entity_engineer_v2 if changes to the inner layers are needed.
        - With every change, review the change and ensure that it follows all the guidelines specified in this task.

      Final Validation:
        - Re-Review After Adjustments: Once the proposed changes have been made, conduct a final review of the game_hierarchy.xml file to ensure all adjustments are correctly implemented and that the file now fully aligns with the game specifications.
        - Confirm Completion: Confirm that the file is complete, accurate, and ready for use in the game development pipeline.

    Indicate whether the game_hierarchy.xml file is approved or if further action is required.
    After completion of all necessary changes, write a concise summary of your findings, including any changes that were proposed and made. 
  expected_output: >
    Report the quality of the game hierarchy.
    Report the completeness of the game hierarchy.
    Report the refining suggestions.

# vim: set foldmethod=indent foldlevel=0:

_task_common: &task_common
  human_input: false
  async_execution: false

game_hierarchy_representation_v2:
  <<: *task_common
  agent: hierarchy_architect_v2
  description: |
    You are given the details and specification of an HTML5 game: {game_specifications}
    Follow these steps to produce your output that will be a single file called game_hierarch.xml:

    Step 1 - Place the original game_specifications under the "Metadata" element as the first element in the game_hierarchy.xml
    Step 2 - Examin the provided game specifications and propose the outermost layer of the game hierarchy and initialize the game_hierarchy.xml file. The definition of a game hierarchy is delimited by triple quotes below.

    """
    The game hierarchy of a game is a comprehensive guide that outlines the vision, concept,
    mechanics, and various aspects of a video game. It serves as a reference for developers,
    designers, artists, and other stakeholders involved in the game's creation.
    """

    Step 3 - The outermost layer should include the following components with the descriptions according to the give game specifications:

    - Metadata: game_specifications of the game
    - Game (root)
      - Board: represents the game grid
      - Bag: contains tiles players can draw
      - TurnManager: manages player turns
      - Player: represents a player in the game
      - Logic: the core game mechanics
      - Audio: the required audio resources for the game

    Step 4 - Provide names and descriptions for each component and define their relationships.
    Step 5 - Delegate the creation of inner layers to hierarchy_entity_engineer_v2. One component at a time.
    Step 6 - Once the game hierarchy generation is completed, pass the game_hierarchy.xml to hierarchy_reviewer_v2 and work together to make sure that the generated game hierarchy is complete and representative of the provided game_specifications.

    Your final answer will be delivered to next task to fill out the inner layers of the game hierarchy.

  expected_output: >
    A sample output format is delimited by triple quotes below for you reference.

    """
    <Metadata>
        <Description>Word2048 merges the sliding tile mechanics of 2048 with the word-building creativity of Scrabble...</Description>
    </Metadata>
    <Game>
        <Board>
            <Description>Represents the 15x15 grid where players place their tiles.</Description>
        </Board>
        <Bag>
            <Description>Contains tiles players can draw.</Description>
        </Bag>
        <TurnManager>
            <Description>Manages player turns.</Description>
        </TurnManager>
        <Player>
            <Description>Represents a player in the game.</Description>
        </Player>
        <Logic>
            <Description>The core game mechanics.</Description>
        </Logic>
        <Audio>
            <Description>The required audio resources for the game.</Description>
        </Audio>
    </Game>
    """

game_hierarchy_inner_layers_task:
  <<: *task_common
  agent: hierarchy_architect_v2
  description: |

    Complete the following steps:

    Step 1 - Learn the structure of the outermost layer of the game hierarchy from file "game_hierarchy.xml" at the beginning by reading the file.
    Step 2 - Fill out details, up to method abstractions of the game hierarchy, including details for Board, Bag, TurnManager, Player, Logic, Audio and other necessary components. Here is a detailed outline for the inner layer elements for each component in the outer layer of the game hierarchy that you need to generate for the provided game description: {game_specifications}. All features in game description should be covered in the inner layer elements.

    - Game (root): The root node representing the overall game and its main components.

    -- Board:
    --- Description: Represents the game grid where the gameplay occurs.
    --- Grid Layout: Dimensions of the grid (e.g., 10x10, 8x8).
    --- Cell Properties: Types of cells (e.g., normal, special, obstacles).
    --- Initialization: How the board is set up at the beginning of the game.
    --- Interaction: How players interact with the board (e.g., placing tiles, moving pieces).
    --- State Management: How the state of the board is tracked and updated.

    -- Bag
    --- Description: Contains the tiles or pieces that players can draw during the game.
    --- Tile Types: Different types of tiles available (e.g., letter tiles, number tiles, special tiles).
    --- Tile Distribution: Quantity and distribution of each tile type.
    --- Draw Mechanism: How players draw tiles from the bag (e.g., random draw, specific conditions).
    --- Reshuffling: Rules for reshuffling the tiles if necessary.

    -- TurnManager
    --- Description: Manages the sequence of player turns.
    --- Turn Order: Rules for determining the order of turns (e.g., clockwise, random).
    --- Turn Phases: Breakdown of actions in each turn (e.g., draw phase, action phase, end phase).
    --- Timers: Any time limits on player turns.
    --- Special Conditions: Handling of special turn-related events (e.g., skipping a turn, extra turn).

    -- Player
    --- Description: Represents a player in the game.
    --- Player Properties: Attributes of players (e.g., name, score, current tiles).
    --- Actions: List of actions a player can take (e.g., draw tile, place tile, pass).
    --- Inventory: How a player's inventory (e.g., hand of tiles) is managed.
    --- Win Conditions: Criteria for winning the game (e.g., highest score, completing a specific task).

    -- Logic
    --- Description: The core game mechanics and rules.
    --- Game Rules: Detailed rules that govern gameplay.
    --- Scoring System: How players earn points and the criteria for scoring.
    --- Valid Moves: Definition of valid and invalid moves.
    --- Event Handling: How game events and interactions are processed.
    --- End Game Conditions: Conditions that trigger the end of the game (e.g., all tiles used, time limit reached).

    -- Audio
    --- Description: The required audio resources for the game.
    --- Background Music: Tracks for different parts of the game (e.g., menu, gameplay, victory).
    --- Sound Effects: List of sound effects needed (e.g., tile placement, player actions, notifications).
    --- Voice Acting: Any voice lines or narrations (e.g., tutorial guidance, character dialogues).
    --- Audio Integration: How audio is integrated and triggered within the game (e.g., event-based sounds, background loops).
    --- Volume Control: Options for adjusting audio settings (e.g., music volume, sound effects volume).

    Step 3 - Explicitly define the properties of each element in the game hierarchy.
    Step 4 - Explicitly define the relationship to other elements in the game hierarchy.
    Step 5 - Ensure that all class names are CamelCase, method names are camelCase, and variables are snake_case. Implement the relationships between components as specified (has_one, has_many, belongs_to).
    Step 6 - Write your result for each outer layer component at the appropriate location in the game_hierarchy.xml file.
  expected_output: >
    An updated game_hierarchy.xml file with the inner layer elements filled out for the corresponding outer layer component in its appropirate position, as well as saved it in a separate XML file.

hierarchy_review_v2:
  <<: *task_common
  agent: hierarchy_reviewer_v2
  description: >
    Read the details and specification of an HTML5 game as provided here: {game_specifications}
    Review the game_hierarchy.xml file for detailedness and completeness in accordance with the provided game_specifications. Ensure that all components
    are well-defined and relationships are correctly implemented. Lint the file to ensure proper naming
    conventions for classes, methods, and variables. Check for the following:
    - Completeness: Ensure all components (Board, Tile, Player, Bag, TurnManager, Score, Logic, Audio) are present with detailed descriptions.
    - Relationships: Verify that all relationships (has_one, has_many, belongs_to) are correctly defined.
    - Naming Conventions: Ensure class names are CamelCase, method names are camelCase, and variables are snake_case.
    Provide feedback and suggest improvements if necessary.
    If anything is missing or incorrect, report to hierarchy_architect_v2 and get it fixed.
  expected_output: >
    Report the quality of the game hierarchy.
    Report the completeness of the game hierarchy.
    Report the refining suggestions.

# vim: set foldmethod=indent foldlevel=0:

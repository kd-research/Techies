_task_common: &task_common
  human_input: false
  async_execution: false

game_hierarchy_representation_v2:
  <<: *task_common
  agent: hierarchy_architect_v2
  description: >
    You are given the details and specification of an HTML5 game: {game_specifications}    
    Read the list of neccesary game mechanics from the current directory.
    Follow these steps to produce your output that will be a single file called game_hierarch.xml:

    Step 1 - Place the original game_specifications under the "Metadata" element as the first element in the game_hierarchy.xml
    Step 2 - Examin the provided game specifications and propose the outermost layer of the game hierarchy and initialize the game_hierarchy.xml file. The definition of a game hierarchy is delimited by triple quotes below.

    """
    The game hierarchy of a game is a comprehensive guide that outlines the vision, concept,
    mechanics, and various aspects of a video game. It serves as a reference for developers,
    designers, artists, and other stakeholders involved in the game's creation.
    """

    Step 3 - The outermost layer should include the following components with the descriptions according to the given game specifications add any additional components as deemed necessary:
    
    - Metadata: game_specifications of the game
    - Game (root)
      - Board: represents the game grid
      - Player: represents a player in the game
      - Logic: the core game mechanics
      - Audio: the required audio resources for the game
      - Images: the required image resources for the game
      - Rules: The rules of the game 

    Step 4 - Provide names and descriptions for each component and define their relationships.
    Step 5 - Delegate the creation of inner layers to hierarchy_entity_engineer_v2. One component at a time.
    Step 6 - Once the game hierarchy generation is completed, pass the game_hierarchy.xml to hierarchy_reviewer_v2 and work together to make sure that the generated game hierarchy is complete and representative of the provided game_specifications.

    Your final answer will be delivered to next task to fill out the inner layers of the game hierarchy.

  expected_output: >
    A sample output format is delimited by triple quotes below for you reference.

    """
    <Metadata>
        <Description>Word2048 merges the sliding tile mechanics of 2048 with the word-building creativity of Scrabble...</Description>
    </Metadata>
    <Game>
        <Board>
            <Description>Represents the 15x15 grid where players place their tiles.</Description>
        </Board>
        <Player>
            <Description>Represents a player in the game.</Description>
        </Player>
        <Logic>
            <Description>The core game mechanics.</Description>
        </Logic>
        <Audio>
            <Description>The required audio resources for the game.</Description>
        </Audio>
        <Images>
            <Description>The required image resources for the game.</Description>
        </Images>
        <Rules>
            <Description>The rules of the game.</Description>
        </Rules>
        <Bag>
            <Description>Contains tiles players can draw.</Description>
        </Bag>
        <TurnManager>
            <Description>Manages player turns.</Description>
        </TurnManager>
    </Game>
    """

game_hierarchy_inner_layers_task:
  <<: *task_common
  agent: hierarchy_architect_v2
  description: |

    Complete the following steps:

    Step 1 - Learn the structure of the outermost layer of the game hierarchy from file "game_hierarchy.xml" at the beginning by reading the file.
    Step 2 - Fill out details, up to method abstractions of the game hierarchy, including details for Board, Bag, TurnManager, Player, Logic, Audio and other necessary components. Here is a detailed outline for the inner layer elements for each component in the outer layer of the game hierarchy that you need to generate for the provided game description: {game_specifications}. All features in game description should be covered in the inner layer elements.

    - Game (root): The root node representing the overall game and its main components.

    -- Board
    --- Description: Represents the game grid where the gameplay occurs.
    --- Grid Layout: Dimensions of the grid (e.g., 10x10, 8x8).
    --- Cell Properties: Types of cells (e.g., normal, special, obstacles).
    --- Initialization: How the board is set up at the beginning of the game.
    --- Interaction: How players interact with the board (e.g., placing tiles, moving pieces).
    --- State Management: How the state of the board is tracked and updated.
    
    -- Player
    --- Description: Represents a player in the game.
    --- Player Properties: Attributes of players (e.g., name, score, current tiles).
    --- Actions: List of actions a player can take (e.g., draw tile, place tile, pass).
    --- Inventory: How a player's inventory (e.g., hand of tiles) is managed.
    --- Win Conditions: Criteria for winning the game (e.g., highest score, completing a specific task).

    -- Logic
    --- Description: The core game mechanics and rules.
    --- Game Rules: Detailed rules that govern gameplay.
    --- Scoring System: How players earn points and the criteria for scoring.
    --- Valid Moves: Definition of valid and invalid moves.
    --- Event Handling: How game events and interactions are processed.
    --- End Game Conditions: Conditions that trigger the end of the game (e.g., all tiles used, time limit reached).

    -- Audio
    --- Description: The required audio resources for the game.
    --- Background Music: Tracks for different parts of the game (e.g., menu, gameplay, victory).
    --- Sound Effects: List of sound effects needed (e.g., tile placement, player actions, notifications).
    --- Voice Acting: Any voice lines or narrations (e.g., tutorial guidance, character dialogues).
    --- Audio Integration: How audio is integrated and triggered within the game (e.g., event-based sounds, background loops).
    --- Volume Control: Options for adjusting audio settings (e.g., music volume, sound effects volume).

    -- Images
    --- Description: Visual representations associated with the game.
    --- Board Images: Images for different parts of the game (e.g., background, board, pieces, buttons).
    --- Player Avatars: Images representing different player characters or avatars.
    --- Item Icons: Icons or images for different items, tiles, or game pieces.
    --- UI: Images for UI elements (e.g., buttons, menus, HUD elements).

    -- Rules
    --- Description: The required rules menu that gives comprehensive rules and instructions for playing the game. It includes information on how players interact with the game world, achieve objectives, and any specific guidelines or restrictions.

    --- Objective
    ----- Description: The primary goal or purpose of the game that players strive to achieve. This can include winning conditions, completing specific tasks, or reaching a certain score.
    ----- Victory Conditions: Detailed criteria for winning the game. This may include scenarios such as achieving the highest score, fulfilling a series of objectives, or outlasting opponents.

    --- Controls
    ----- Description: The input methods used to control gameplay. This section defines the various controls available to players and their corresponding actions.
    ----- Control Scheme: A comprehensive list of controls and their functions (e.g., keyboard keys, mouse clicks, gamepad buttons). For each control, specify what it does in the context of the game.

    --- Actions
    ----- Description: Defines the possible actions a player can take during gameplay, including interactions with the game world and other players.
    ----- Action List: A detailed list of all actions available to players, such as moving pieces, drawing cards, or using special abilities. Each action should be described with its effects and any relevant rules.
    ----- Action Restrictions: Guidelines on when and how actions can be performed, including any limitations or conditions that must be met.

    Step 3 - Explicitly define the properties of each element in the game hierarchy.
    Step 4 - Explicitly define the relationship to other elements in the game hierarchy.
    Step 5 - Ensure that all class names are CamelCase, method names are camelCase, and variables are snake_case. Implement the relationships between components as specified (has_one, has_many, belongs_to).
    Step 6 - Write your result for each outer layer component at the appropriate location in the game_hierarchy.xml file.
  expected_output: >
    An updated game_hierarchy.xml file with the inner layer elements filled out for the corresponding outer layer component in its appropirate position, as well as saved it in a separate XML file.

hierarchy_review_v2:
  <<: *task_common
  agent: hierarchy_reviewer_v2
  description: >
    Read the details and specification of an HTML5 game as provided here: {game_specifications}
    Review the game_hierarchy.xml file for detailedness and completeness in accordance with the provided game_specifications. Ensure that all components
    are well-defined and relationships are correctly implemented. Lint the file to ensure proper naming
    conventions for classes, methods, and variables. Check for the following:
    - Completeness: Ensure all components (Board, Tile, Player, Logic, Audio, and Rules) are present with detailed descriptions.
    - Relationships: Verify that all relationships (has_one, has_many, belongs_to) are correctly defined.
    - Naming Conventions: Ensure class names are CamelCase, method names are camelCase, and variables are snake_case.
    Provide feedback and suggest improvements if necessary.
    If anything is missing or incorrect, report to hierarchy_architect_v2 and get it fixed.
  expected_output: >
    Report the quality of the game hierarchy.
    Report the completeness of the game hierarchy.
    Report the refining suggestions.

# vim: set foldmethod=indent foldlevel=0:
